<!DOCTYPE html></!DOCTYPE html><html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><title>Making a Bots2 clone using Lenses and Pipes - Ben Kovach</title><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><style type="text/css">body{background-color:#eeeeee !important;font-family:"Ubuntu", serif !important}body .ui.container{font-family:"Ubuntu", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Kanit", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body div#neuron-theme-default-teal .zettel-content h1{background-color:rgba(0,181,173,0.1)}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a{color:#00b5ad}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#00b5ad}body div#neuron-theme-default-teal .deemphasized:hover div.item a:hover{color:#00b5ad !important}body div#neuron-theme-default-teal div#footnotes{border-top-color:#00b5ad}body div#neuron-theme-default-brown .zettel-content h1{background-color:rgba(165,103,63,0.1)}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a{color:#a5673f}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a5673f}body div#neuron-theme-default-brown .deemphasized:hover div.item a:hover{color:#a5673f !important}body div#neuron-theme-default-brown div#footnotes{border-top-color:#a5673f}body div#neuron-theme-default-red .zettel-content h1{background-color:rgba(219,40,40,0.1)}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a{color:#db2828}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#db2828}body div#neuron-theme-default-red .deemphasized:hover div.item a:hover{color:#db2828 !important}body div#neuron-theme-default-red div#footnotes{border-top-color:#db2828}body div#neuron-theme-default-orange .zettel-content h1{background-color:rgba(242,113,28,0.1)}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a{color:#f2711c}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#f2711c}body div#neuron-theme-default-orange .deemphasized:hover div.item a:hover{color:#f2711c !important}body div#neuron-theme-default-orange div#footnotes{border-top-color:#f2711c}body div#neuron-theme-default-yellow .zettel-content h1{background-color:rgba(251,189,8,0.1)}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a{color:#fbbd08}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#fbbd08}body div#neuron-theme-default-yellow .deemphasized:hover div.item a:hover{color:#fbbd08 !important}body div#neuron-theme-default-yellow div#footnotes{border-top-color:#fbbd08}body div#neuron-theme-default-olive .zettel-content h1{background-color:rgba(181,204,24,0.1)}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a{color:#b5cc18}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#b5cc18}body div#neuron-theme-default-olive .deemphasized:hover div.item a:hover{color:#b5cc18 !important}body div#neuron-theme-default-olive div#footnotes{border-top-color:#b5cc18}body div#neuron-theme-default-green .zettel-content h1{background-color:rgba(33,186,69,0.1)}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a{color:#21ba45}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#21ba45}body div#neuron-theme-default-green .deemphasized:hover div.item a:hover{color:#21ba45 !important}body div#neuron-theme-default-green div#footnotes{border-top-color:#21ba45}body div#neuron-theme-default-blue .zettel-content h1{background-color:rgba(33,133,208,0.1)}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a{color:#2185d0}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#2185d0}body div#neuron-theme-default-blue .deemphasized:hover div.item a:hover{color:#2185d0 !important}body div#neuron-theme-default-blue div#footnotes{border-top-color:#2185d0}body div#neuron-theme-default-violet .zettel-content h1{background-color:rgba(100,53,201,0.1)}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a{color:#6435c9}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#6435c9}body div#neuron-theme-default-violet .deemphasized:hover div.item a:hover{color:#6435c9 !important}body div#neuron-theme-default-violet div#footnotes{border-top-color:#6435c9}body div#neuron-theme-default-purple .zettel-content h1{background-color:rgba(163,51,200,0.1)}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a{color:#a333c8}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a333c8}body div#neuron-theme-default-purple .deemphasized:hover div.item a:hover{color:#a333c8 !important}body div#neuron-theme-default-purple div#footnotes{border-top-color:#a333c8}body div#neuron-theme-default-pink .zettel-content h1{background-color:rgba(224,57,151,0.1)}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a{color:#e03997}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#e03997}body div#neuron-theme-default-pink .deemphasized:hover div.item a:hover{color:#e03997 !important}body div#neuron-theme-default-pink div#footnotes{border-top-color:#e03997}body div#neuron-theme-default-grey .zettel-content h1{background-color:rgba(118,118,118,0.1)}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a{color:#767676}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#767676}body div#neuron-theme-default-grey .deemphasized:hover div.item a:hover{color:#767676 !important}body div#neuron-theme-default-grey div#footnotes{border-top-color:#767676}body div#neuron-theme-default-black .zettel-content h1{background-color:rgba(27,28,29,0.1)}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a{color:#1b1c1d}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#1b1c1d}body div#neuron-theme-default-black .deemphasized:hover div.item a:hover{color:#1b1c1d !important}body div#neuron-theme-default-black div#footnotes{border-top-color:#1b1c1d}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.84999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f8f8f8}body div.zettel-view .zettel-content pre{padding:0.5em 0.5em 0.5em 0.5em;overflow:auto;max-width:100%}body div.zettel-view .zettel-content div.pandoc-code{margin-left:auto;margin-right:auto}body div.zettel-view .zettel-content div.pandoc-code pre{background-color:#f8f8f8}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.backlinks-container{background-color:#eeeeee !important}body ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body ul.context-list > li{list-style-type:lower-roman}body span.zettel-link-container span.zettel-link a{font-weight:bold;text-decoration:none}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}body nav.top-menu{padding-top:1em;padding-bottom:1em;justify-content:center;text-align:center}body nav.top-menu > *{padding-left:0px;padding-right:0px}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}</style><link href="https://fonts.googleapis.com/css?family=Kanit|Ubuntu|Roboto+Mono&amp;display=swap" rel="stylesheet" /><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta content="Ben Kovach" name="author" /><meta content="When I was in high school, I came across an internet game called bots2.
Bots2 was a multiplayer game where people can log in, customize a robot,
and autonomously fight against pre-built AI and other human players. The
game would progress in rounds, wherein each robot would attempt to
destroy its adv" name="description" /><link href="https://kovach.me/Making_a_Bots2_clone_using_Lenses_and_Pipes.html" rel="canonical" /><meta content="Making a Bots2 clone using Lenses and Pipes" property="og:title" /><meta content="Ben Kovach" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[]</script><style type="text/css">pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style></head><body><div class="ui fluid container" id="neuron-theme-default-blue"><nav class="top-menu"><div class="ui inverted compact neuron icon menu blue"><a class="left item" href="." title="Home"><i class="home icon"></i></a><a class="left item" href="search.html" title="Search Zettels"><i class="search icon"></i></a><a class="center item" href="https://github.com/5outh/zettelkasten/edit/master/Making a Bots2 clone using Lenses and Pipes.md" title="Edit this Zettel"><i class="edit icon"></i></a><a class="right item" href="z-index.html" title="All Zettels (z-index)"><i class="tree icon"></i></a></div></nav><div class="ui text container" id="zettel-container" style="position: relative"><div id="zettel-container-anchor" style="position: absolute; top: -24px; left: 0"></div><div class="zettel-view"><article class="ui raised attached segment zettel-content"><h1>Making a Bots2 clone using Lenses and Pipes</h1><div class="pandoc"><h4 id="about-bots2">About bots2</h4><p>When I was in high school, I came across an internet game called bots2. Bots2 was a multiplayer game where people can log in, customize a robot, and autonomously fight against pre-built AI and other human players. The game would progress in rounds, wherein each robot would attempt to destroy its adversary. The game would continue until one robot dropped below 0 health, at which point the other robot would emerge victorious.</p><p>Bots2 was purportedly <a href="http://bots4.net/documentation">attacked by hackers</a> and never brought back up. However, <a href="http://edmazur.com/">someone</a> has taken the liberty of creating a clone of the old game, named bots4. If you’re interested, <a href="http://bots4.net/">you can play bots4 here</a>. In fact, I might recommend playing around with it for a minute or two, because we’ll be building a (very) simple version of bots2 in this post!</p><h4 id="preliminaries">Preliminaries</h4><p>I only assume a basic familiarity with monad transformers in this post. If you need an introduction, <a href="http://blog.sigfpe.com">sigfpe</a> has a <a href="http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html">great introduction to them on his blog</a>. We’ll be using Russell O’Connor’s <a href="http://hackage.haskell.org/package/lens-family">Lens-Family</a> and Gabriel Gonzalez’ <a href="http://hackage.haskell.org/package/pipes">Pipes</a> libraries to make the implementation easy (and educational!).</p><p>I also want to give a shout out to Gabriel, who was generous enough to personally review and edit my initial draft of the code in this post – it looks much better than it did before, thanks to him.</p><p>Without further ado, let’s get started!</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">import</span><span class="">           </span><span class="dt">Pipes</span>
<span class="kw">import</span><span class=""> </span><span class="kw">qualified</span><span class=""> </span><span class="dt">Pipes.Prelude</span><span class=""> </span><span class="kw">as</span><span class=""> </span><span class="dt">P</span>
<span class="kw">import</span><span class=""> </span><span class="kw">qualified</span><span class=""> </span><span class="dt">System.Random</span><span class=""> </span><span class="kw">as</span><span class=""> </span><span class="dt">R</span>
<span class="kw">import</span><span class="">           </span><span class="dt">Lens.Family2</span><span class="">             </span>
<span class="kw">import</span><span class="">           </span><span class="dt">Lens.Family2.Stock</span><span class="">       </span>
<span class="kw">import</span><span class="">           </span><span class="dt">Lens.Family2.State.Lazy</span><span class=""> </span>
<span class="kw">import</span><span class="">           </span><span class="dt">Control.Monad.Trans.State</span>
<span class="kw">import</span><span class="">           </span><span class="dt">Control.Monad</span>
<span class="kw">import</span><span class="">           </span><span class="dt">Control.Concurrent</span><span class="">(threadDelay)</span>
</code></pre></div><h4 id="modeling-bots">Modeling Bots</h4><p>The game we wish to build pits two bots against each other, who will fight to the death based on who has the better stats (and a bit of randomness). We’ll need to be able to model each bot as an entity along with its specific stats.</p><p>During each round, each bot:</p><ol><li>Deals damage to its opponent</li><li>Has a chance to block (and take half damage)</li><li>Has a chance to dodge (and take no damage)</li></ol><p>We’ll model a <code>Bot</code> like so:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">data</span><span class=""> </span><span class="dt">Bot</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">Bot</span>
<span class="">    {</span><span class="ot"> _name ::</span><span class=""> </span><span class="dt">String</span>
<span class="">    ,</span><span class="ot"> _str  ::</span><span class=""> </span><span class="dt">Int</span>
<span class="">    ,</span><span class="ot"> _dex  ::</span><span class=""> </span><span class="dt">Int</span>
<span class="">    ,</span><span class="ot"> _con  ::</span><span class=""> </span><span class="dt">Int</span>
<span class="">    ,</span><span class="ot"> _hp   ::</span><span class=""> </span><span class="dt">Int</span>
<span class="">    } </span><span class="kw">deriving</span><span class=""> (</span><span class="dt">Show</span><span class="">, </span><span class="dt">Eq</span><span class="">)</span>
</code></pre></div><p>We’ll use <code>str</code> to modify damage output, <code>dex</code> to modify dodge chance, <code>con</code> to modify block chance, and <code>hp</code> to denote the amount of health the bot has remaining. We’ll also tack on a <code>name</code> so we can print out more informative messages during the game. Note the prefix <code>_</code> on each field; these are here so we can give our <code>Lens</code>es nicer names.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">name ::</span><span class=""> </span><span class="dt">Lens&#39;</span><span class=""> </span><span class="dt">Bot</span><span class=""> </span><span class="dt">String</span>
<span class="">str, dex, con,</span><span class="ot"> hp ::</span><span class=""> </span><span class="dt">Lens&#39;</span><span class=""> </span><span class="dt">Bot</span><span class=""> </span><span class="dt">Int</span>
<span class="">name k (</span><span class="dt">Bot</span><span class=""> nm s d c h)  </span><span class="ot">=</span><span class=""> </span><span class="fu">fmap</span><span class=""> (\nm&#39; </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Bot</span><span class=""> nm&#39; s d c h) (k nm)</span>
<span class="">str  k (</span><span class="dt">Bot</span><span class=""> nm s d c h)  </span><span class="ot">=</span><span class=""> </span><span class="fu">fmap</span><span class=""> (\s&#39;  </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Bot</span><span class=""> nm s&#39; d c h) (k s )</span>
<span class="">dex  k (</span><span class="dt">Bot</span><span class=""> nm s d c h)  </span><span class="ot">=</span><span class=""> </span><span class="fu">fmap</span><span class=""> (\d&#39;  </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Bot</span><span class=""> nm s d&#39; c h) (k d )</span>
<span class="">con  k (</span><span class="dt">Bot</span><span class=""> nm s d c h)  </span><span class="ot">=</span><span class=""> </span><span class="fu">fmap</span><span class=""> (\c&#39;  </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Bot</span><span class=""> nm s d c&#39; h) (k c )</span>
<span class="">hp   k (</span><span class="dt">Bot</span><span class=""> nm s d c h)  </span><span class="ot">=</span><span class=""> </span><span class="fu">fmap</span><span class=""> (\h&#39;  </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Bot</span><span class=""> nm s d c h&#39;) (k h )</span>
</code></pre></div><p>We can now define some <code>Lens</code>es for our <code>Bot</code> fields. We do this manually because it’s relatively simple and to avoid the <code>TemplateHaskell</code> requirement that comes along with Edward Kmett’s larger <a href="http://hackage.haskell.org/package/lens-3.10.0.1">Lens</a> library. Given a more complicated system, we might choose to use <a href="http://hackage.haskell.org/package/lens-3.10.0.1">Lens</a> to automatically generate these. However, this is a small program so the overhead isn’t necessary. Also, don’t worry too much about the declarations of the <code>Lens</code>es above: Just know that they allow us to do some cool stuff later on.</p><p>With these <code>Lens</code>es defined and our <code>Bot</code> data type in place, we can move on to defining more of the game’s semantics.</p><h4 id="more-types">More Types</h4><p>We’ll need a data type to represent a bot’s actions during a single round, and a game state representing the global state of the game:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">type</span><span class=""> </span><span class="dt">Event</span><span class="">    </span><span class="ot">=</span><span class=""> (</span><span class="dt">Int</span><span class="">, </span><span class="dt">Bool</span><span class="">, </span><span class="dt">Bool</span><span class="">)</span>
<span class="kw">type</span><span class=""> </span><span class="dt">BotState</span><span class=""> </span><span class="ot">=</span><span class=""> (</span><span class="dt">R.StdGen</span><span class="">, (</span><span class="dt">Bot</span><span class="">, </span><span class="dt">Bot</span><span class="">))</span>
</code></pre></div><p>The <code>Event</code> type defines a round of a single Bot’s behavior in a 3-tuple – the first parameter corresponds to damage dealt, the second to whether or not the bot dodged, and the third to whether or not the bot blocked. We will process these events later.</p><p>The <code>BotState</code> type boxes up a <code>StdGen</code> for us to use when generating random events, and a 2-tuple of <code>Bot</code>s – the player character’s bot and the enemy AI. This is all the global state we need in our game.</p><p>We can make some new <code>Lens</code>es for these types, given that 2-tuples are easily indexed using <code>Lens</code>:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">generator ::</span><span class=""> </span><span class="dt">Lens&#39;</span><span class=""> </span><span class="dt">BotState</span><span class=""> </span><span class="dt">R.StdGen</span>
<span class="">generator </span><span class="ot">=</span><span class=""> _1</span>

<span class="ot">player ::</span><span class=""> </span><span class="dt">Lens&#39;</span><span class=""> </span><span class="dt">BotState</span><span class=""> </span><span class="dt">Bot</span>
<span class="">player </span><span class="ot">=</span><span class=""> _2</span><span class="op">.</span><span class="">_1</span>

<span class="ot">enemy ::</span><span class=""> </span><span class="dt">Lens&#39;</span><span class=""> </span><span class="dt">BotState</span><span class=""> </span><span class="dt">Bot</span>
<span class="">enemy </span><span class="ot">=</span><span class=""> _2</span><span class="op">.</span><span class="">_2</span>
</code></pre></div><p>Here we create a <code>Lens</code> that references the <code>StdGen</code> of the <code>BotState</code>, using <code>_1</code>. We can also compose <code>Lens</code>es using <code>.</code> (from the <code>Prelude</code>!) and we use this functionality with the simple <code>Lens</code>es <code>_1</code> and <code>_2</code> to make <code>Lens</code>es referencing the player and enemy AI in a <code>BotState</code>.</p><p>Well, that’s about all the type declaring we need to do. Now we can get on with piecing together the actual gameplay.</p><h4 id="generating-events">Generating Events</h4><p>Now comes the fun part: actually programming the game mechanics. Essentially what we’d like to do is the following:</p><ol><li>Generate an event for the player and enemy at the same time.</li><li>Process each event.</li><li>If either bot is dead, end the game and print an ending message.</li></ol><p>Here we’ll focus on (1), generating events. Let’s take a look at some code:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">genEvent ::</span><span class=""> </span><span class="dt">Bot</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">StateT</span><span class=""> </span><span class="dt">R.StdGen</span><span class=""> </span><span class="dt">IO</span><span class=""> </span><span class="dt">Event</span>
<span class="">genEvent bot </span><span class="ot">=</span><span class=""> </span><span class="kw">do</span>
<span class="">    [n, m, r] </span><span class="ot">&lt;-</span><span class=""> replicateM </span><span class="dv">3</span><span class=""> </span><span class="op">$</span><span class=""> state (R.randomR (</span><span class="dv">0</span><span class="">, </span><span class="dv">100</span><span class="">))</span>
<span class="">    </span><span class="kw">let</span><span class=""> dodge </span><span class="ot">=</span><span class=""> n </span><span class="op">&lt;</span><span class=""> </span><span class="dv">100</span><span class=""> </span><span class="op">*</span><span class=""> bot</span><span class="op">^.</span><span class="">dex </span><span class="ot">`div`</span><span class=""> (bot</span><span class="op">^.</span><span class="">dex </span><span class="op">+</span><span class=""> </span><span class="dv">50</span><span class="">)</span>
<span class="">        block </span><span class="ot">=</span><span class=""> m </span><span class="op">&lt;</span><span class=""> </span><span class="dv">100</span><span class=""> </span><span class="op">*</span><span class=""> bot</span><span class="op">^.</span><span class="">con </span><span class="ot">`div`</span><span class=""> (bot</span><span class="op">^.</span><span class="">con </span><span class="op">+</span><span class=""> </span><span class="dv">30</span><span class="">)</span>
<span class="">        dmg   </span><span class="ot">=</span><span class=""> bot</span><span class="op">^.</span><span class="">str </span><span class="op">+</span><span class=""> (bot</span><span class="op">^.</span><span class="">str </span><span class="op">*</span><span class=""> r) </span><span class="ot">`div`</span><span class=""> </span><span class="dv">30</span>
<span class="">    </span><span class="fu">return</span><span class=""> (dmg, dodge, block)</span>
</code></pre></div><p>In order to generate an event for a bot, we grab three numbers between 0 and 100:</p><ul><li>n, which helps determine if the bot dodges,</li><li>m, which helps determine if the bot blocks,</li><li>and r, which helps determine how much damage the bot does.</li></ul><p>We can use the <code>state</code> combinator here to lift the computation <code>(R.randomR (0, 100))</code> to a computation in the <code>StateT</code> monad. We then perform some arithmetic using the random numbers we grabbed along with the <code>dex</code>, <code>con</code>, and <code>str</code> stats from our <code>Bot</code>. We access these using the <code>^.</code> combinator from the <code>lens-family</code>, using the <code>Lens</code>es we defined above.</p><p>Important note: We are producing the amount of damage a bot <em>deals</em> here. We will want to process events according to how much damage each bot <em>receives</em>, which we’ll handle in a minute.</p><p>Now that we can generate single events, we need a way of mapping them to specific bots. We’ll define a new function, <code>genEventPair</code>, to generate <em>two</em> events at once, corresponding to the player and the enemy in the game.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">genEventPair ::</span><span class=""> </span><span class="dt">StateT</span><span class=""> </span><span class="dt">BotState</span><span class=""> </span><span class="dt">IO</span><span class=""> (</span><span class="dt">Event</span><span class="">, </span><span class="dt">Event</span><span class="">)</span>
<span class="">genEventPair </span><span class="ot">=</span><span class=""> </span><span class="kw">do</span>
<span class="">    p </span><span class="ot">&lt;-</span><span class=""> use player</span>
<span class="">    e </span><span class="ot">&lt;-</span><span class=""> use enemy</span>
<span class="">    zoom generator </span><span class="op">$</span><span class=""> liftM2 switchDmgs (genEvent p) (genEvent e)</span>
<span class="">  </span><span class="kw">where</span>
<span class="">    switchDmgs (a, b, c) (d, e, f) </span><span class="ot">=</span><span class=""> ( (d, b, c), (a, e, f) )</span>
</code></pre></div><p>There are a couple of new things at play here. First, on <code>use</code>:</p><p>Note the use of our <code>Lens</code>es <code>player</code> and <code>enemy</code>. To access the underlying state in a <code>StateT</code>, we typically call the function <code>lift</code>. Here instead we call the function <code>use</code> from <code>Lens.Family2.State</code>, which allows us to specify which <em>piece</em> of our <code>BotState</code> we want to get. We do just this in order to generate events for both the <code>player</code> and <code>enemy</code>, using the aforementioned <code>Lens</code>es.</p><p>Next, if you were looking closely you might have noticed that <code>genEvent</code> isn’t operating in the same monad as <code>genEventPair</code>, yet we use <code>genEvent</code> inside of <code>genEventPair</code>! We are able do do this using the <code>zoom</code> combinator.</p><p><code>zoom</code> lifts a stateful operation on one field to a stateful operation on the entire state. Here, we’re zooming into <code>generator</code> (a <code>Lens</code> on our <code>StdGen</code>) and lifting the (stateful) generation of events for both the player and enemy into a (stateful) generation of <em>two</em> events while preserving player and enemy states. The fact that we can <code>zoom</code> into <code>genEvent</code> helps out the declaration immensely. It removes a lot of plumbing that we would have had to deal with in order to have <code>genEvent</code> operate on an underlying state of type <code>BotState</code> and allows the type of the computation to be more explicit.</p><p>Finally, Note the use of <code>switchDmgs</code> here: This was an ad hoc way to switch around damage dealt and damage sustained. <code>genEventPair</code> produces events harboring damage <em>taken</em>, which is what we need in order to process them in a nice way.</p><h4 id="processing-events">Processing Events</h4><p>Now that we’re able to generate events and keep track of our game state, the next thing we need to do is actually process these events and update game state. We introduce <code>resolveEvent</code> to take care of this:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">resolveEvent ::</span><span class=""> (</span><span class="dt">Monad</span><span class=""> m) </span><span class="ot">=&gt;</span><span class=""> (</span><span class="dt">Event</span><span class="">, </span><span class="dt">Event</span><span class="">) </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">StateT</span><span class=""> </span><span class="dt">BotState</span><span class=""> m [(</span><span class="dt">Bot</span><span class="">, </span><span class="dt">Event</span><span class="">)]</span>
<span class="">resolveEvent (p_evt, e_evt) </span><span class="ot">=</span><span class=""> </span><span class="kw">do</span>
<span class="">    zoom player (resolve p_evt)</span>
<span class="">    zoom enemy  (resolve e_evt)</span>
<span class="">    p </span><span class="ot">&lt;-</span><span class=""> use player</span>
<span class="">    e </span><span class="ot">&lt;-</span><span class=""> use enemy</span>
<span class="">    </span><span class="fu">return</span><span class=""> [(p, p_evt), (e, e_evt)]</span>

<span class="ot">resolve ::</span><span class=""> (</span><span class="dt">Monad</span><span class=""> m) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Event</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">StateT</span><span class=""> </span><span class="dt">Bot</span><span class=""> m ()</span>
<span class="">resolve (dmg, ddg, blk)</span>
<span class="">    </span><span class="op">|</span><span class=""> ddg       </span><span class="ot">=</span><span class=""> </span><span class="fu">return</span><span class=""> ()</span>
<span class="">    </span><span class="op">|</span><span class=""> blk       </span><span class="ot">=</span><span class=""> hp </span><span class="op">-=</span><span class=""> dmg </span><span class="ot">`div`</span><span class=""> </span><span class="dv">2</span>
<span class="">    </span><span class="op">|</span><span class=""> </span><span class="fu">otherwise</span><span class=""> </span><span class="ot">=</span><span class=""> hp </span><span class="op">-=</span><span class=""> dmg</span>
</code></pre></div><p>First let’s look at the <code>resolve</code> function. Here we are taking an event and updating a <code>Bot</code>’s state based on that event. The implementation is straightforward, especially given that we have the <code>-=</code> <code>Lens</code> combinator at our disposal – this allows us to write imperative-looking code that does exactly what you would expect it to.</p><p>In the <code>resolveEvent</code> function, you should see some similarities to the above section. We can again use <code>zoom</code> and <code>use</code> in order to lift computations and retrieve state just as before, but we’re updating the main game state now. We produce two 2-tuples containing modified bots and their attached event that was processed during each turn.</p><p>At this point, the game logic is actually finished. We have ways to produce and deal with game events that modify game state, and provided that we can actually link these functions together (which we can, as we’ll see later), the game will actually run. All that we need to do now is handle IO and bot death. This is where <code>Pipes</code> comes in.</p><h4 id="pipes-and-io">Pipes and IO</h4><p>Let’s get the boring stuff out of the way first. I mentioned above that we have yet to deal with two major components of our game: IO and bot death. Let’s first define some simple functions to deal with these:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">dead ::</span><span class=""> </span><span class="dt">Bot</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Bool</span>
<span class="">dead </span><span class="ot">=</span><span class=""> (</span><span class="op">&lt;=</span><span class=""> </span><span class="dv">0</span><span class="">) </span><span class="op">.</span><span class=""> view hp</span>

<span class="ot">printBot ::</span><span class=""> </span><span class="dt">Bot</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">IO</span><span class=""> ()</span>
<span class="">printBot bot </span><span class="ot">=</span><span class=""> </span><span class="fu">putStrLn</span><span class=""> </span><span class="op">$</span><span class=""> bot</span><span class="op">^.</span><span class="">name </span><span class="op">++</span><span class=""> </span><span class="st">&quot; has &quot;</span><span class=""> </span><span class="op">++</span><span class=""> </span><span class="fu">show</span><span class=""> (bot</span><span class="op">^.</span><span class="">hp) </span><span class="op">++</span><span class=""> </span><span class="st">&quot; hp remaining.&quot;</span>

<span class="ot">printEvent ::</span><span class=""> </span><span class="dt">Bot</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Event</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">IO</span><span class=""> ()</span>
<span class="">printEvent bot (_, </span><span class="dt">True</span><span class="">, _) </span><span class="ot">=</span><span class=""> </span><span class="fu">putStrLn</span><span class=""> </span><span class="op">$</span>
<span class="">  bot</span><span class="op">^.</span><span class="">name </span><span class="op">++</span><span class=""> </span><span class="st">&quot; dodges the attack and takes no damage!&quot;</span>
<span class="">printEvent bot (d, _, </span><span class="dt">True</span><span class="">) </span><span class="ot">=</span><span class=""> </span><span class="fu">putStrLn</span><span class=""> </span><span class="op">$</span><span class=""> </span>
<span class="">  bot</span><span class="op">^.</span><span class="">name </span><span class="op">++</span><span class=""> </span><span class="st">&quot; blocks and takes half (&quot;</span><span class=""> </span><span class="op">++</span><span class=""> </span><span class="fu">show</span><span class=""> (d </span><span class="ot">`div`</span><span class=""> </span><span class="dv">2</span><span class="">) </span><span class="op">++</span><span class=""> </span><span class="st">&quot;) damage!&quot;</span>
<span class="">printEvent bot (d, _,    _) </span><span class="ot">=</span><span class=""> </span><span class="fu">putStrLn</span><span class=""> </span><span class="op">$</span><span class=""> </span>
<span class="">  bot</span><span class="op">^.</span><span class="">name </span><span class="op">++</span><span class=""> </span><span class="st">&quot; takes &quot;</span><span class=""> </span><span class="op">++</span><span class=""> </span><span class="fu">show</span><span class=""> d </span><span class="op">++</span><span class=""> </span><span class="st">&quot; damage.&quot;</span>
</code></pre></div><p>Here we again make use of our <code>Lens</code>es (these are handy, huh?). We use the <code>view</code> function in order to get the health of our bot in <code>dead</code>, and check whether its hp is less than 0 in the usual fashion. <code>view</code> is just a prefix synonym for the infix <code>^.</code> that we’ve been using all this time. Speaking of which, we use the <code>^.</code> combinator heavily in both <code>printEvent</code> and <code>printBot</code> to handle the string-handling plumbing. Since these functions essentially tell you what they’re doing implicitly, I’ll omit an extensive explanation.</p><p>Now that we have ways to print <code>Bot</code>s and <code>Event</code>s and check for bot death, the last thing we need to do is actually perform these things the context of our game. A <code>Consumer</code> from the <code>Pipes</code> library will handle this nicely for us:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">printGame ::</span><span class=""> </span><span class="dt">Consumer</span><span class=""> [(</span><span class="dt">Bot</span><span class="">, </span><span class="dt">Event</span><span class="">)] (</span><span class="dt">StateT</span><span class=""> </span><span class="dt">BotState</span><span class=""> </span><span class="dt">IO</span><span class="">) ()</span>
<span class="">printGame </span><span class="ot">=</span><span class=""> </span><span class="kw">do</span>
<span class="">    botEvents</span><span class="op">@</span><span class="">[(b1, e1), (b2, e2)] </span><span class="ot">&lt;-</span><span class=""> await</span>
<span class="">    (lift </span><span class="op">.</span><span class=""> lift) </span><span class="op">$</span><span class=""> </span><span class="kw">do</span>
<span class="">        forM_ botEvents </span><span class="op">$</span><span class=""> \be</span><span class="op">@</span><span class="">(bot, event) </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">do</span>
<span class="">            </span><span class="fu">uncurry</span><span class=""> printEvent be</span>
<span class="">            printBot bot</span>
<span class="">            threadDelay </span><span class="dv">500000</span>
<span class="">            when (dead bot) </span><span class="op">$</span><span class=""> </span><span class="fu">putStrLn</span><span class=""> </span><span class="op">$</span><span class=""> bot</span><span class="op">^.</span><span class="">name </span><span class="op">++</span><span class=""> </span><span class="st">&quot; died!&quot;</span>
<span class="">        </span><span class="fu">putStrLn</span><span class=""> </span><span class="op">$</span><span class=""> </span><span class="kw">case</span><span class=""> (dead b1, dead b2) </span><span class="kw">of</span>
<span class="">            (</span><span class="dt">True</span><span class=""> , </span><span class="dt">True</span><span class=""> ) </span><span class="ot">-&gt;</span><span class=""> </span><span class="st">&quot;It was a tie!&quot;</span>
<span class="">            (</span><span class="dt">True</span><span class=""> , </span><span class="dt">False</span><span class="">) </span><span class="ot">-&gt;</span><span class=""> b2</span><span class="op">^.</span><span class="">name </span><span class="op">++</span><span class=""> </span><span class="st">&quot; wins!&quot;</span>
<span class="">            (</span><span class="dt">False</span><span class="">, </span><span class="dt">True</span><span class=""> ) </span><span class="ot">-&gt;</span><span class=""> b1</span><span class="op">^.</span><span class="">name </span><span class="op">++</span><span class=""> </span><span class="st">&quot; wins!&quot;</span>
<span class="">            _              </span><span class="ot">-&gt;</span><span class=""> </span><span class="st">&quot;-----------------&quot;</span>
<span class="">    unless (</span><span class="fu">any</span><span class=""> (dead </span><span class="op">.</span><span class=""> </span><span class="fu">fst</span><span class="">) botEvents) printGame</span>
</code></pre></div><p>We <code>await</code> two <code>(Bot, Event)</code>s (from where, you might ask? We’ll see in a moment.) and essentially handle all of the plumbing here. For each pair of bots and events, we print the event, print the bot, then wait half a second with <code>threadDelay</code> (otherwise the game would run too quickly and we wouldn’t see it play out). With a <code>Consumer</code> like this, we need to loop until we’ve consumed all of the input we want, so we use the <code>when</code> and <code>unless</code> functions from <code>Control.Monad</code> as indicators of when to do so. If a bot dies, we stop – we also print out some information about who died and who won the game.</p><h4 id="running-the-game">Running the Game</h4><p>Okay, so I say that we have everything we need now, but you might ask…how do I run this? Let’s take a look at a program that pits two bots – a good guy and a bad guy – against one another, and we’ll dissect it.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">runGame ::</span><span class=""> </span><span class="dt">IO</span><span class=""> ()</span>
<span class="">runGame </span><span class="ot">=</span><span class=""> </span><span class="kw">do</span>
<span class="">    gen </span><span class="ot">&lt;-</span><span class=""> R.getStdGen</span>
<span class="">    </span><span class="kw">let</span><span class=""> player </span><span class="ot">=</span><span class=""> </span><span class="dt">Bot</span><span class=""> </span><span class="st">&quot;The Good Guy&quot;</span><span class=""> </span><span class="dv">19</span><span class=""> </span><span class="dv">13</span><span class=""> </span><span class="dv">12</span><span class=""> </span><span class="dv">200</span>
<span class="">        enemy  </span><span class="ot">=</span><span class=""> </span><span class="dt">Bot</span><span class=""> </span><span class="st">&quot;The Bad Guy&quot;</span><span class="">  </span><span class="dv">14</span><span class=""> </span><span class="dv">6</span><span class="">  </span><span class="dv">10</span><span class=""> </span><span class="dv">200</span>
<span class="">        startState </span><span class="ot">=</span><span class=""> (gen, (player, enemy))</span>
<span class="">    </span><span class="fu">flip</span><span class=""> evalStateT startState </span>
<span class="">      </span><span class="op">$</span><span class=""> runEffect </span>
<span class="">      </span><span class="op">$</span><span class=""> lift (genEventPair </span><span class="op">&gt;&gt;=</span><span class=""> resolveEvent) </span><span class="op">&gt;~</span><span class=""> printGame</span>
</code></pre></div><p>In the first few lines, we simply set up an initial state for the game. The real “stuff” happens in the line starting with <code>flip evalStateT</code>. We’ll work through this at a type level from the inside-out. First, we perform <code>genEventPair &gt;&gt;= resolveEvent</code>, which effectively handles the logic we talked about earlier and produces a <code>StateT BotState IO [(Bot, Event)]</code>. From here, we <code>lift</code> the computation into an <code>Effect (StateT BotState IO) [(Bot, Event)]</code>, which we then repeatedly pipe into <code>printGame</code> with <code>&gt;~</code>. After all of this, we <code>runEffect</code> to extract the <code>StateT BotState IO [(Bot, Event)]</code> from the computation, and finally evaluate the function using <code>evalStateT</code>. Phew!</p><p>In any case, we can now run our program and execute the game…</p><div class="pandoc-code highlighted"><pre><code class="c"><span class="">*Main&gt; runGame</span>
<span class="">The Good Guy takes </span><span class="dv">15</span><span class=""> damage.</span>
<span class="">The Good Guy has </span><span class="dv">285</span><span class=""> hp remaining.</span>
<span class="">The Bad Guy takes </span><span class="dv">29</span><span class=""> damage.</span>
<span class="">The Bad Guy has </span><span class="dv">171</span><span class=""> hp remaining.</span>
<span class="">-----------------</span>
<span class="">The Good Guy dodges the attack and takes no damage!</span>
<span class="">The Good Guy has </span><span class="dv">285</span><span class=""> hp remaining.</span>
<span class="">The Bad Guy takes </span><span class="dv">20</span><span class=""> damage.</span>
<span class="">The Bad Guy has </span><span class="dv">151</span><span class=""> hp remaining.</span>
<span class="">-----------------</span>
<span class="">The Good Guy blocks and takes half (</span><span class="dv">24</span><span class="">) damage!</span>
<span class="">The Good Guy has </span><span class="dv">261</span><span class=""> hp remaining.</span>
<span class="">The Bad Guy takes </span><span class="dv">34</span><span class=""> damage.</span>
<span class="">The Bad Guy has </span><span class="dv">117</span><span class=""> hp remaining.</span>
<span class="">-----------------</span>
<span class="">The Good Guy takes </span><span class="dv">46</span><span class=""> damage.</span>
<span class="">The Good Guy has </span><span class="dv">215</span><span class=""> hp remaining.</span>
<span class="">The Bad Guy takes </span><span class="dv">19</span><span class=""> damage.</span>
<span class="">The Bad Guy has </span><span class="dv">98</span><span class=""> hp remaining.</span>
<span class="">-----------------</span>
<span class="">The Good Guy takes </span><span class="dv">32</span><span class=""> damage.</span>
<span class="">The Good Guy has </span><span class="dv">183</span><span class=""> hp remaining.</span>
<span class="">The Bad Guy takes </span><span class="dv">37</span><span class=""> damage.</span>
<span class="">The Bad Guy has </span><span class="dv">61</span><span class=""> hp remaining.</span>
<span class="">-----------------</span>
<span class="">The Good Guy dodges the attack and takes no damage!</span>
<span class="">The Good Guy has </span><span class="dv">183</span><span class=""> hp remaining.</span>
<span class="">The Bad Guy takes </span><span class="dv">12</span><span class=""> damage.</span>
<span class="">The Bad Guy has </span><span class="dv">49</span><span class=""> hp remaining.</span>
<span class="">-----------------</span>
<span class="">The Good Guy takes </span><span class="dv">24</span><span class=""> damage.</span>
<span class="">The Good Guy has </span><span class="dv">159</span><span class=""> hp remaining.</span>
<span class="">The Bad Guy takes </span><span class="dv">23</span><span class=""> damage.</span>
<span class="">The Bad Guy has </span><span class="dv">26</span><span class=""> hp remaining.</span>
<span class="">-----------------</span>
<span class="">The Good Guy dodges the attack and takes no damage!</span>
<span class="">The Good Guy has </span><span class="dv">159</span><span class=""> hp remaining.</span>
<span class="">The Bad Guy takes </span><span class="dv">36</span><span class=""> damage.</span>
<span class="">The Bad Guy has -</span><span class="dv">10</span><span class=""> hp remaining.</span>
<span class="">The Bad Guy died!</span>
<span class="">The Good Guy wins!</span>
</code></pre></div><p>…and behold, the good guy wins (this time)!</p><p><a href="https://gist.github.com/5outh/8049361">View full source on GitHub</a>.</p><p>- Ben</p></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2013-12-19">2013-12-19</time></div></div></article><nav class="ui bottom attached segment deemphasized backlinks-container"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" data-inverted="" data-position="right center" data-tooltip="Tags: home"><a href=".">Ben Kovach</a></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc">Linking by tag: <code>Essays</code></div></li></ul></li></ul><a class="ui right ribbon label zettel-tag " href="search.html?tag=Haskell" title="See all zettels tagged &#39;Haskell&#39;">Haskell</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Essays" title="See all zettels tagged &#39;Essays&#39;">Essays</a><p></p></nav></div></div><div class="ui one column grid footer-version"><div class="center aligned column"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron" /></a></div></div></div></div></body></html>