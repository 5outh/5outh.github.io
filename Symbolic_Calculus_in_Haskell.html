<!DOCTYPE html></!DOCTYPE html><html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><title>Symbolic Calculus in Haskell - Ben Kovach</title><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><style type="text/css">body{background-color:#eeeeee !important;font-family:"Ubuntu", serif !important}body .ui.container{font-family:"Ubuntu", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Kanit", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body div#neuron-theme-default-teal .zettel-content h1{background-color:rgba(0,181,173,0.1)}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a{color:#00b5ad}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#00b5ad}body div#neuron-theme-default-teal .deemphasized:hover div.item a:hover{color:#00b5ad !important}body div#neuron-theme-default-teal div#footnotes{border-top-color:#00b5ad}body div#neuron-theme-default-brown .zettel-content h1{background-color:rgba(165,103,63,0.1)}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a{color:#a5673f}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a5673f}body div#neuron-theme-default-brown .deemphasized:hover div.item a:hover{color:#a5673f !important}body div#neuron-theme-default-brown div#footnotes{border-top-color:#a5673f}body div#neuron-theme-default-red .zettel-content h1{background-color:rgba(219,40,40,0.1)}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a{color:#db2828}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#db2828}body div#neuron-theme-default-red .deemphasized:hover div.item a:hover{color:#db2828 !important}body div#neuron-theme-default-red div#footnotes{border-top-color:#db2828}body div#neuron-theme-default-orange .zettel-content h1{background-color:rgba(242,113,28,0.1)}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a{color:#f2711c}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#f2711c}body div#neuron-theme-default-orange .deemphasized:hover div.item a:hover{color:#f2711c !important}body div#neuron-theme-default-orange div#footnotes{border-top-color:#f2711c}body div#neuron-theme-default-yellow .zettel-content h1{background-color:rgba(251,189,8,0.1)}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a{color:#fbbd08}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#fbbd08}body div#neuron-theme-default-yellow .deemphasized:hover div.item a:hover{color:#fbbd08 !important}body div#neuron-theme-default-yellow div#footnotes{border-top-color:#fbbd08}body div#neuron-theme-default-olive .zettel-content h1{background-color:rgba(181,204,24,0.1)}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a{color:#b5cc18}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#b5cc18}body div#neuron-theme-default-olive .deemphasized:hover div.item a:hover{color:#b5cc18 !important}body div#neuron-theme-default-olive div#footnotes{border-top-color:#b5cc18}body div#neuron-theme-default-green .zettel-content h1{background-color:rgba(33,186,69,0.1)}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a{color:#21ba45}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#21ba45}body div#neuron-theme-default-green .deemphasized:hover div.item a:hover{color:#21ba45 !important}body div#neuron-theme-default-green div#footnotes{border-top-color:#21ba45}body div#neuron-theme-default-blue .zettel-content h1{background-color:rgba(33,133,208,0.1)}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a{color:#2185d0}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#2185d0}body div#neuron-theme-default-blue .deemphasized:hover div.item a:hover{color:#2185d0 !important}body div#neuron-theme-default-blue div#footnotes{border-top-color:#2185d0}body div#neuron-theme-default-violet .zettel-content h1{background-color:rgba(100,53,201,0.1)}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a{color:#6435c9}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#6435c9}body div#neuron-theme-default-violet .deemphasized:hover div.item a:hover{color:#6435c9 !important}body div#neuron-theme-default-violet div#footnotes{border-top-color:#6435c9}body div#neuron-theme-default-purple .zettel-content h1{background-color:rgba(163,51,200,0.1)}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a{color:#a333c8}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a333c8}body div#neuron-theme-default-purple .deemphasized:hover div.item a:hover{color:#a333c8 !important}body div#neuron-theme-default-purple div#footnotes{border-top-color:#a333c8}body div#neuron-theme-default-pink .zettel-content h1{background-color:rgba(224,57,151,0.1)}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a{color:#e03997}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#e03997}body div#neuron-theme-default-pink .deemphasized:hover div.item a:hover{color:#e03997 !important}body div#neuron-theme-default-pink div#footnotes{border-top-color:#e03997}body div#neuron-theme-default-grey .zettel-content h1{background-color:rgba(118,118,118,0.1)}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a{color:#767676}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#767676}body div#neuron-theme-default-grey .deemphasized:hover div.item a:hover{color:#767676 !important}body div#neuron-theme-default-grey div#footnotes{border-top-color:#767676}body div#neuron-theme-default-black .zettel-content h1{background-color:rgba(27,28,29,0.1)}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a{color:#1b1c1d}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#1b1c1d}body div#neuron-theme-default-black .deemphasized:hover div.item a:hover{color:#1b1c1d !important}body div#neuron-theme-default-black div#footnotes{border-top-color:#1b1c1d}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.84999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f8f8f8}body div.zettel-view .zettel-content pre{padding:0.5em 0.5em 0.5em 0.5em;overflow:auto;max-width:100%}body div.zettel-view .zettel-content div.pandoc-code{margin-left:auto;margin-right:auto}body div.zettel-view .zettel-content div.pandoc-code pre{background-color:#f8f8f8}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.backlinks-container{background-color:#eeeeee !important}body ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body ul.context-list > li{list-style-type:lower-roman}body span.zettel-link-container span.zettel-link a{font-weight:bold;text-decoration:none}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}body nav.top-menu{padding-top:1em;padding-bottom:1em;justify-content:center;text-align:center}body nav.top-menu > *{padding-left:0px;padding-right:0px}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}</style><link href="https://fonts.googleapis.com/css?family=Kanit|Ubuntu|Roboto+Mono&amp;display=swap" rel="stylesheet" /><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta content="Ben Kovach" name="author" /><meta content="It’s relatively simple to write a program to approximate derivatives. We
simply look at the limit definition of a derivative:
$$ \frac{d}{dx}
f(x) = \lim_{h \rightarrow 0} \frac{f(x+h) - f(x)}{h} $$
and choose some small decimal number to use for h instead of calculating
the limit of the function as" name="description" /><link href="https://kovach.me/Symbolic_Calculus_in_Haskell.html" rel="canonical" /><meta content="Symbolic Calculus in Haskell" property="og:title" /><meta content="Ben Kovach" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[]</script><style type="text/css">pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style></head><body><div class="ui fluid container" id="neuron-theme-default-blue"><nav class="top-menu"><div class="ui inverted compact neuron icon menu blue"><a class="left item" href="." title="Home"><i class="home icon"></i></a><a class="left item" href="search.html" title="Search Zettels"><i class="search icon"></i></a><a class="center item" href="https://github.com/5outh/zettelkasten/edit/master/Symbolic Calculus in Haskell.md" title="Edit this Zettel"><i class="edit icon"></i></a><a class="right item" href="z-index.html" title="All Zettels (z-index)"><i class="tree icon"></i></a></div></nav><div class="ui text container" id="zettel-container" style="position: relative"><div id="zettel-container-anchor" style="position: absolute; top: -24px; left: 0"></div><div class="zettel-view"><article class="ui raised attached segment zettel-content"><h1>Symbolic Calculus in Haskell</h1><div class="pandoc"><h4 id="motivation">Motivation</h4><p>It’s relatively simple to write a program to approximate derivatives. We simply look at the limit definition of a derivative: <span class="math display">$$ \frac{d}{dx}
f(x) = \lim_{h \rightarrow 0} \frac{f(x+h) - f(x)}{h} $$</span> and choose some small decimal number to use for <span class="math inline">\(h\)</span> instead of calculating the limit of the function as it goes to <span class="math inline">\(0\)</span>. Generally, this works pretty well. We get good approximations as long as <span class="math inline">\(h\)</span> is small enough. However, these approximations are not quite exact, and they can only be evaluated at specific points (for example, we can find <span class="math inline">\(\frac{d}{dx}f(5)\)</span>, but not the actual symbolic function). So, what if we want to know what <span class="math inline">\(\frac{d}{dx}f(x)\)</span> is <em>for all x</em>? Calculating derivatives with this approximation method won’t do the trick for us – we’ll need something a little more powerful, which is what we will build in this post. Admittedly, this idea didn’t come to me through necessity of such a system; I was just curious. It ended up being pretty enlightening, and it’s amazing how simple Haskell makes this type of thing. Most of the code in this post didn’t take too long to write, it’s relatively short (only 108 lines total, including whitespace) and has a lot of capability. With that, let’s get started!</p><h4 id="the-data-type">The Data Type</h4><p>I don’t want to over-complicate the process of taking derivatives, so my data type for algebraic expressions is kept minimal. We support six different types of expressions:</p><ul><li>Variables (denoted by a single character)</li><li>Constant values</li><li>Addition</li><li>Multiplication</li><li>Exponentiation</li><li>Division</li></ul><p>This can be expanded upon, but this is adequate for the purpose of demonstration.</p><p>Here is our <code>Expr a</code> type, with a sample expression representing <span class="math inline">\(3x^2\)</span>:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">infixl</span><span class=""> </span><span class="dv">4</span><span class=""> </span><span class="op">:+:</span>
<span class="kw">infixl</span><span class=""> </span><span class="dv">5</span><span class=""> </span><span class="op">:*:</span><span class="">, </span><span class="op">:/:</span>
<span class="kw">infixr</span><span class=""> </span><span class="dv">6</span><span class=""> </span><span class="op">:^:</span>

<span class="kw">data</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">=</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="dt">Char</span>
<span class="">             </span><span class="op">|</span><span class=""> </span><span class="dt">Const</span><span class=""> a </span>
<span class="">             </span><span class="op">|</span><span class=""> (</span><span class="dt">Expr</span><span class=""> a) </span><span class="op">:+:</span><span class=""> (</span><span class="dt">Expr</span><span class=""> a) </span>
<span class="">             </span><span class="op">|</span><span class=""> (</span><span class="dt">Expr</span><span class=""> a) </span><span class="op">:*:</span><span class=""> (</span><span class="dt">Expr</span><span class=""> a)</span>
<span class="">             </span><span class="op">|</span><span class=""> (</span><span class="dt">Expr</span><span class=""> a) </span><span class="op">:^:</span><span class=""> (</span><span class="dt">Expr</span><span class=""> a)</span>
<span class="">             </span><span class="op">|</span><span class=""> (</span><span class="dt">Expr</span><span class=""> a) </span><span class="op">:/:</span><span class=""> (</span><span class="dt">Expr</span><span class=""> a)</span>
<span class="">             </span><span class="kw">deriving</span><span class=""> (</span><span class="dt">Show</span><span class="">, </span><span class="dt">Eq</span><span class="">)</span>

<span class="ot">sampleExpr ::</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span><span class="dt">Double</span>
<span class="">sampleExpr </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">3</span><span class=""> </span><span class="op">:*:</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="op">:^:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">2</span><span class=""> </span><span class="co">--3x^2</span>
</code></pre></div><p>Haskell allows infix operators to act as data constructors, which allows us to express algebraic expressions cleanly and concisely without too much mental parsing. Also note that, since we explicitly defined operator precedence above the data type declaration, we can write expressions without parentheses according to order of operations, like we did in the sample expression.</p><h4 id="the-algebra">The Algebra</h4><p>Taking derivatives simply by the rules can get messy, so we might as well go ahead and set up an algebra simplification function that cleans up our final expressions for us. This is actually incredibly simple. As long as you know algebraic laws, this kind of thing basically writes itself in Haskell. We just need to pattern match against certain expressions and meld them together according to algebraic law. This function ends up being lengthy long due to the fact that symbolic manipulation is mostly just a bunch of different cases, but we can encode algebraic simplification rules for our above data type in a straightforward way. The following simplify function takes an expression and spits out a simpler one that means the same thing. It’s really just a bunch of pattern-matching cases, so feel free to skim it.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">simplify ::</span><span class=""> (</span><span class="dt">Num</span><span class=""> a, </span><span class="dt">Eq</span><span class=""> a, </span><span class="dt">Floating</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a</span>
<span class="">simplify (</span><span class="dt">Const</span><span class=""> a </span><span class="op">:+:</span><span class=""> </span><span class="dt">Const</span><span class=""> b) </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> (a </span><span class="op">+</span><span class=""> b)</span>
<span class="">simplify (a       </span><span class="op">:+:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span><span class="">) </span><span class="ot">=</span><span class=""> simplify a</span>
<span class="">simplify (</span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span><span class=""> </span><span class="op">:+:</span><span class=""> a      ) </span><span class="ot">=</span><span class=""> simplify a</span>

<span class="">simplify (</span><span class="dt">Const</span><span class=""> a </span><span class="op">:*:</span><span class=""> </span><span class="dt">Const</span><span class=""> b) </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> (a</span><span class="op">*</span><span class="">b)</span>
<span class="">simplify (a </span><span class="op">:*:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">1</span><span class="">)         </span><span class="ot">=</span><span class=""> simplify a</span>
<span class="">simplify (</span><span class="dt">Const</span><span class=""> </span><span class="dv">1</span><span class=""> </span><span class="op">:*:</span><span class=""> a)         </span><span class="ot">=</span><span class=""> simplify a</span>
<span class="">simplify (a </span><span class="op">:*:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span><span class="">)         </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span>
<span class="">simplify (</span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span><span class=""> </span><span class="op">:*:</span><span class=""> a)         </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span>

<span class="">simplify (</span><span class="dt">Const</span><span class=""> a </span><span class="op">:^:</span><span class=""> </span><span class="dt">Const</span><span class=""> b)       </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> (a</span><span class="op">**</span><span class="">b)</span>
<span class="">simplify (a </span><span class="op">:^:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">1</span><span class="">)             </span><span class="ot">=</span><span class=""> simplify a</span>
<span class="">simplify (a </span><span class="op">:^:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span><span class="">)             </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">1</span>
<span class="">simplify ((c </span><span class="op">:^:</span><span class=""> </span><span class="dt">Const</span><span class=""> b) </span><span class="op">:^:</span><span class=""> </span><span class="dt">Const</span><span class=""> a) </span><span class="ot">=</span><span class=""> c </span><span class="op">:^:</span><span class=""> (</span><span class="dt">Const</span><span class=""> (a</span><span class="op">*</span><span class="">b))</span>

<span class="">simplify (</span><span class="dt">Const</span><span class=""> a </span><span class="op">:*:</span><span class=""> (</span><span class="dt">Const</span><span class=""> b </span><span class="op">:*:</span><span class=""> expr)) </span><span class="ot">=</span><span class=""> (</span><span class="dt">Const</span><span class=""> </span><span class="op">$</span><span class=""> a</span><span class="op">*</span><span class="">b) </span><span class="op">:*:</span><span class=""> (simplify expr)</span>
<span class="">simplify (</span><span class="dt">Const</span><span class=""> a </span><span class="op">:*:</span><span class=""> expr </span><span class="op">:*:</span><span class=""> </span><span class="dt">Const</span><span class=""> b) </span><span class="ot">=</span><span class=""> (</span><span class="dt">Const</span><span class=""> </span><span class="op">$</span><span class=""> a</span><span class="op">*</span><span class="">b) </span><span class="op">:*:</span><span class=""> (simplify expr)</span>
<span class="">simplify (expr </span><span class="op">:*:</span><span class=""> </span><span class="dt">Const</span><span class=""> a </span><span class="op">:*:</span><span class=""> </span><span class="dt">Const</span><span class=""> b) </span><span class="ot">=</span><span class=""> (</span><span class="dt">Const</span><span class=""> </span><span class="op">$</span><span class=""> a</span><span class="op">*</span><span class="">b) </span><span class="op">:*:</span><span class=""> (simplify expr)</span>
<span class="">simplify (</span><span class="dt">Const</span><span class=""> a </span><span class="op">:*:</span><span class=""> (b </span><span class="op">:+:</span><span class=""> c)) </span><span class="ot">=</span>
<span class="">  (</span><span class="dt">Const</span><span class=""> a </span><span class="op">:*:</span><span class=""> (simplify b)) </span><span class="op">:+:</span><span class=""> (</span><span class="dt">Const</span><span class=""> a </span><span class="op">:*:</span><span class=""> (simplify c))</span>

<span class="">simplify (</span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span><span class=""> </span><span class="op">:/:</span><span class=""> a        ) </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span>
<span class="">simplify (</span><span class="dt">Const</span><span class=""> a </span><span class="op">:/:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span><span class="">)   </span><span class="ot">=</span><span class=""> </span><span class="fu">error</span><span class=""> </span><span class="st">&quot;Division by zero!&quot;</span>
<span class="">simplify (</span><span class="dt">Const</span><span class=""> a </span><span class="op">:/:</span><span class=""> </span><span class="dt">Const</span><span class=""> b)   </span><span class="op">|</span><span class=""> a </span><span class="op">==</span><span class=""> b </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">1</span><span class=""> </span><span class="co">-- only when a == b</span>
<span class="">simplify (a       </span><span class="op">:/:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">1</span><span class="">)   </span><span class="ot">=</span><span class=""> simplify a</span>

<span class="">simplify (a </span><span class="op">:/:</span><span class=""> b)  </span><span class="ot">=</span><span class=""> (simplify a) </span><span class="op">:/:</span><span class=""> (simplify b)</span>
<span class="">simplify (a </span><span class="op">:^:</span><span class=""> b)  </span><span class="ot">=</span><span class=""> (simplify a) </span><span class="op">:^:</span><span class=""> (simplify b)</span>
<span class="">simplify (a </span><span class="op">:*:</span><span class=""> b)  </span><span class="ot">=</span><span class=""> (simplify a) </span><span class="op">:*:</span><span class=""> (simplify b)</span>
<span class="">simplify (a </span><span class="op">:+:</span><span class=""> b)  </span><span class="ot">=</span><span class=""> (simplify a) </span><span class="op">:+:</span><span class=""> (simplify b)</span>
<span class="">simplify x          </span><span class="ot">=</span><span class=""> </span><span class="fu">id</span><span class=""> x</span>

<span class="">fullSimplify expr </span><span class="ot">=</span><span class=""> fullSimplify&#39; expr (</span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span><span class="">) </span><span class="co">-- placeholder</span>
<span class="">  </span><span class="kw">where</span><span class=""> fullSimplify&#39; cur </span><span class="fu">last</span><span class=""> </span><span class="op">|</span><span class=""> cur </span><span class="op">==</span><span class=""> </span><span class="fu">last</span><span class=""> </span><span class="ot">=</span><span class=""> cur</span>
<span class="">                               </span><span class="op">|</span><span class=""> </span><span class="fu">otherwise</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="kw">let</span><span class=""> cur&#39; </span><span class="ot">=</span><span class=""> simplify cur</span>
<span class="">                                             </span><span class="kw">in</span><span class=""> fullSimplify&#39; cur&#39; cur</span>
</code></pre></div><p>I’ve also included a <code>fullSimplify</code> function that runs simplify on an expression until the current input matches the last output of simplify (which ensures an expression is completely simplified)*. Note that in the <code>simplify</code> function, I’ve covered a lot of bases, but not all of them. Specifically, division simplification is lacking because it gets complicated quickly and I didn’t want to focus on that in this blog post. We should also note that we don’t have a data type expressing subtraction or negative numbers, so we’ll deal with that now. In order to express the negation of expressions, we define the <code>negate&#39;</code> function, which basically multiplies expressions by <span class="math inline">\(-1\)</span> and outputs the resultant expression.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">negate&#39; ::</span><span class=""> (</span><span class="dt">Num</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a</span>
<span class="">negate&#39; (</span><span class="dt">Var</span><span class=""> c)    </span><span class="ot">=</span><span class=""> (</span><span class="dt">Const</span><span class=""> (</span><span class="op">-</span><span class="dv">1</span><span class="">)) </span><span class="op">:*:</span><span class=""> (</span><span class="dt">Var</span><span class=""> c)</span>
<span class="">negate&#39; (</span><span class="dt">Const</span><span class=""> a)  </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> (</span><span class="op">-</span><span class="">a)</span>
<span class="">negate&#39; (a </span><span class="op">:+:</span><span class=""> b)  </span><span class="ot">=</span><span class=""> (negate&#39; a) </span><span class="op">:+:</span><span class=""> (negate&#39; b)</span>
<span class="">negate&#39; (a </span><span class="op">:*:</span><span class=""> b)  </span><span class="ot">=</span><span class=""> (negate&#39; a) </span><span class="op">:*:</span><span class=""> b</span>
<span class="">negate&#39; (a </span><span class="op">:^:</span><span class=""> b)  </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> (</span><span class="op">-</span><span class="dv">1</span><span class="">) </span><span class="op">:*:</span><span class=""> a </span><span class="op">:^:</span><span class=""> b</span>
<span class="">negate&#39; (a </span><span class="op">:/:</span><span class=""> b)  </span><span class="ot">=</span><span class=""> (negate&#39; a) </span><span class="op">:/:</span><span class=""> b</span>
</code></pre></div><p>Now we have a relatively robust system for computing symbolic expressions. However, we aren’t able to actually plug anything into these expressions yet, so we’ll fix that now.</p><p><em>*Thanks to <a href="http://reddit.com/u/zoells">/u/zoells</a> for the suggestion!</em></p><h4 id="evaluating-expressions">Evaluating Expressions</h4><p>The first thing we’ll need to do to begin the process of evaluating expressions is write a function to plug in a value for a specific variable. We do this in terms of a function called <code>mapVar</code>, implemented as follows:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">mapVar ::</span><span class=""> (</span><span class="dt">Char</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a</span>
<span class="">mapVar f (</span><span class="dt">Var</span><span class=""> d)   </span><span class="ot">=</span><span class=""> f d</span>
<span class="">mapVar _ (</span><span class="dt">Const</span><span class=""> a) </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> a</span>
<span class="">mapVar f (a </span><span class="op">:+:</span><span class=""> b) </span><span class="ot">=</span><span class=""> (mapVar f a) </span><span class="op">:+:</span><span class=""> (mapVar f b)</span>
<span class="">mapVar f (a </span><span class="op">:*:</span><span class=""> b) </span><span class="ot">=</span><span class=""> (mapVar f a) </span><span class="op">:*:</span><span class=""> (mapVar f b)</span>
<span class="">mapVar f (a </span><span class="op">:^:</span><span class=""> b) </span><span class="ot">=</span><span class=""> (mapVar f a) </span><span class="op">:^:</span><span class=""> (mapVar f b)</span>
<span class="">mapVar f (a </span><span class="op">:/:</span><span class=""> b) </span><span class="ot">=</span><span class=""> (mapVar f a) </span><span class="op">:/:</span><span class=""> (mapVar f b)</span>

<span class="ot">plugIn ::</span><span class=""> </span><span class="dt">Char</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a</span>
<span class="">plugIn c val </span><span class="ot">=</span><span class=""> mapVar (\x </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">if</span><span class=""> x </span><span class="op">==</span><span class=""> c </span><span class="kw">then</span><span class=""> </span><span class="dt">Const</span><span class=""> val </span><span class="kw">else</span><span class=""> </span><span class="dt">Var</span><span class=""> x)</span>
</code></pre></div><p><code>mapVar</code> searches through an expression for a specific variable and performs a function on each instance of that variable in the function. plugIn takes a character and a value, and is defined using <code>mapVar</code> to map variables with a specific name to a constant provided by the user. Now that we have <code>plugIn</code>, we can define two functions: One that takes an expression full of only constants and outputs a result (<code>evalExpr&#39;</code>), and one that will replace a single variable with a constant and output the result (<code>evalExpr</code>):</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">evalExpr ::</span><span class=""> (</span><span class="dt">Num</span><span class=""> a, </span><span class="dt">Floating</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Char</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> a</span>
<span class="">evalExpr c x </span><span class="ot">=</span><span class=""> evalExpr&#39; </span><span class="op">.</span><span class=""> plugIn c x </span>

<span class="ot">evalExpr&#39; ::</span><span class=""> (</span><span class="dt">Num</span><span class=""> a, </span><span class="dt">Floating</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> a</span>
<span class="">evalExpr&#39; (</span><span class="dt">Const</span><span class=""> a) </span><span class="ot">=</span><span class=""> a</span>
<span class="">evalExpr&#39; (</span><span class="dt">Var</span><span class="">   c) </span><span class="ot">=</span><span class=""> </span><span class="fu">error</span><span class=""> </span><span class="op">$</span><span class=""> </span><span class="st">&quot;Variables (&quot;</span>
<span class="">                              </span><span class="op">++</span><span class=""> [c] </span><span class="op">++</span><span class=""> </span>
<span class="">                              </span><span class="st">&quot;) still exist in formula. Try plugging in a value!&quot;</span>
<span class="">evalExpr&#39; (a </span><span class="op">:+:</span><span class=""> b) </span><span class="ot">=</span><span class=""> (evalExpr&#39; a) </span><span class="op">+</span><span class=""> (evalExpr&#39; b)</span>
<span class="">evalExpr&#39; (a </span><span class="op">:*:</span><span class=""> b) </span><span class="ot">=</span><span class=""> (evalExpr&#39; a) </span><span class="op">*</span><span class=""> (evalExpr&#39; b)</span>
<span class="">evalExpr&#39; (a </span><span class="op">:^:</span><span class=""> b) </span><span class="ot">=</span><span class=""> (evalExpr&#39; a) </span><span class="op">**</span><span class=""> (evalExpr&#39; b)</span>
<span class="">evalExpr&#39; (a </span><span class="op">:/:</span><span class=""> b) </span><span class="ot">=</span><span class=""> (evalExpr&#39; a) </span><span class="op">/</span><span class=""> (evalExpr&#39; b)</span>
</code></pre></div><p>What we’re doing here is simple. With <code>evalExpr&#39;</code>, we only need to replace our functional types (<code>:+:</code>, <code>:*:</code>, etc) with the actual functions (<code>+</code>, <code>*</code>, etc). When we run into a <code>Const</code>, we simply replace it with it’s inner number value. When we run into a <code>Var</code>, we note that it’s not possible to evaluate, and tell the user that there is still a variable in the expression that needs to be plugged in. With evalExpr, we just plug in a value for a specific variable before evaluating the expression. Simple as that! Here are some examples of expressions and their evaluations:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> evalExpr </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="dv">2</span><span class=""> (</span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class="">) </span>
<span class="op">&gt;</span><span class=""> </span><span class="fl">2.0</span><span class=""> </span>
<span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> evalExpr </span><span class="ch">&#39;a&#39;</span><span class=""> </span><span class="dv">3</span><span class=""> (</span><span class="dt">Const</span><span class=""> </span><span class="dv">3</span><span class="op">:+:</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;a&#39;</span><span class=""> </span><span class="op">:*:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">6</span><span class="">)</span>
<span class="op">&gt;</span><span class="">  </span><span class="fl">21.0</span><span class=""> </span>
<span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> evalExpr </span><span class="ch">&#39;b&#39;</span><span class=""> </span><span class="dv">2</span><span class=""> (</span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;b&#39;</span><span class=""> </span><span class="op">:/:</span><span class=""> (</span><span class="dt">Const</span><span class=""> </span><span class="dv">2</span><span class=""> </span><span class="op">:*:</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;b&#39;</span><span class="">)) </span>
<span class="op">&gt;</span><span class=""> </span><span class="fl">0.5</span><span class=""> </span>
</code></pre></div><p>We can even evaluate multivariate expressions using <code>plugIn</code>:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> evalExpr&#39; </span><span class="op">.</span><span class=""> plugIn </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="dv">1</span><span class=""> </span><span class="op">$</span><span class=""> plugIn </span><span class="ch">&#39;y&#39;</span><span class=""> </span><span class="dv">2</span><span class=""> (</span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="op">:+:</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;y&#39;</span><span class="">) </span>
<span class="op">&gt;</span><span class=""> </span><span class="fl">3.0</span><span class=""> </span>
</code></pre></div><p>Now that we’ve extended our symbolic expressions to be able to be evaluated, let’s do what we set out to do – find derivatives!</p><h4 id="derivatives">Derivatives</h4><p>We aren’t going to get into super-complicated derivatives involving logorithmic or implicit differentiation, etc. Instead, we’ll keep it simple for now, and only adhere to some of the ‘simple’ derivative rules. We’ll need one of them for each of our six expression types: constants, variables, addition, multiplication, division, and exponentiation. We already know the following laws for these from calculus:</p><table class="ui celled table"><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Differentiation of a constant:</td><td><span class="math display">$$\frac{d}{dx}k = 0$$</span></td></tr><tr><td>Differentiation of a variable:</td><td><span class="math display">$$\frac{d}{dx}x = 1$$</span></td></tr><tr><td>Addition differentiation:</td><td><span class="math display">$$\frac{d}{dx}\left(f(x) + g(x)\right) = \frac{d}{dx}f(x) +\frac{d}{dx}g(x)$$</span></td></tr><tr><td>Power rule (/chain rule):</td><td><span class="math display">$$\frac{d}{dx}f(x)^n = nf(x)^{n-1} \cdot \frac{d}{dx}f(x)$$</span></td></tr><tr><td>Product rule:</td><td><span class="math display">$$\frac{d}{dx}\left(f(x) \cdot g(x)\right) = \frac{d}{dx}f(x) \cdot g(x) + f(x) \cdot \frac{d}{dx}g(x)$$</span></td></tr><tr><td>Quotient rule:</td><td>$$\frac{d}{dx}\frac{f(x)}{g(x)} = \frac{\frac{d}{dx}f(x) \cdot g(x)</td></tr></tbody></table><ul><li>\frac{d}{dx}g(x) \cdot f(x)}{g(x)^2}$$</li></ul><p>As it turns out, we can almost directly represent this in Haskell. There should be no surprises here – following along with the above rules, it is relatively easy to see how this function calculates derivatives. We will still error out if we get something like <span class="math inline">\(x^x\)</span> as input, as it will require a technique we haven’t implemented yet. However, this will suffice for a many different expressions.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">derivative ::</span><span class=""> (</span><span class="dt">Num</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a</span>
<span class="">derivative (</span><span class="dt">Var</span><span class=""> c)           </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">1</span>
<span class="">derivative (</span><span class="dt">Const</span><span class=""> x)         </span><span class="ot">=</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="dv">0</span>

<span class="co">--product rule (ab&#39; + a&#39;b)</span>
<span class="">derivative (a </span><span class="op">:*:</span><span class=""> b)         </span><span class="ot">=</span><span class=""> (a </span><span class="op">:*:</span><span class=""> (derivative b)) </span><span class="op">:+:</span><span class="">  (b </span><span class="op">:*:</span><span class=""> (derivative a)) </span><span class="co">-- product rule</span>

<span class=""> </span><span class="co">--power rule (xa^(x-1) * a&#39;)</span>
<span class="">derivative (a </span><span class="op">:^:</span><span class=""> (</span><span class="dt">Const</span><span class=""> x)) </span><span class="ot">=</span><span class=""> ((</span><span class="dt">Const</span><span class=""> x) </span><span class="op">:*:</span><span class=""> (a </span><span class="op">:^:</span><span class=""> (</span><span class="dt">Const</span><span class=""> </span><span class="op">$</span><span class=""> x</span><span class="op">-</span><span class="dv">1</span><span class="">))) </span><span class="op">:*:</span><span class=""> (derivative a)</span>
<span class="">derivative (a </span><span class="op">:+:</span><span class=""> b)         </span><span class="ot">=</span><span class=""> (derivative a) </span><span class="op">:+:</span><span class=""> (derivative b)</span>

<span class=""> </span><span class="co">-- quotient rule ( (a&#39;b - b&#39;a) / b^2 )</span>
<span class="">derivative (a </span><span class="op">:/:</span><span class=""> b)         </span><span class="ot">=</span><span class=""> ((derivative a </span><span class="op">:*:</span><span class=""> b) </span><span class="op">:+:</span><span class=""> (negate&#39; (derivative b </span><span class="op">:*:</span><span class=""> a))) </span>
<span class="">                               </span><span class="op">:/:</span><span class=""> </span>
<span class="">                               (b </span><span class="op">:^:</span><span class=""> (</span><span class="dt">Const</span><span class=""> </span><span class="dv">2</span><span class="">))</span>
<span class="">derivative expr              </span><span class="ot">=</span><span class=""> </span><span class="fu">error</span><span class=""> </span><span class="st">&quot;I&#39;m not a part of your system!&quot;</span><span class=""> </span><span class="co">-- unsupported operation</span>

<span class="ot">ddx ::</span><span class=""> (</span><span class="dt">Floating</span><span class=""> a, </span><span class="dt">Eq</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a</span>
<span class="">ddx </span><span class="ot">=</span><span class=""> fullSimplify </span><span class="op">.</span><span class=""> derivative  </span>

<span class="ot">ddxs ::</span><span class=""> (</span><span class="dt">Floating</span><span class=""> a, </span><span class="dt">Eq</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> [</span><span class="dt">Expr</span><span class=""> a]</span>
<span class="">ddxs </span><span class="ot">=</span><span class=""> </span><span class="fu">iterate</span><span class=""> ddx</span>

<span class="ot">nthDerivative ::</span><span class=""> (</span><span class="dt">Floating</span><span class=""> a, </span><span class="dt">Eq</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Int</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a</span>
<span class="">nthDerivative n </span><span class="ot">=</span><span class=""> </span><span class="fu">foldr1</span><span class=""> (</span><span class="op">.</span><span class="">) (</span><span class="fu">replicate</span><span class=""> n ddx)</span>
</code></pre></div><p>So, what can we do with this? Well, let’s take a look:</p><p>The first, most obvious thing we’ll note when running the derivative function on an expression is that what it produces is rather ugly. To fix this, we’ll write a function ddx that will simplify the derivative expression three times to make our output cleaner. (Remember <code>sampleExpr</code> = <span class="math inline">\(3x^2\)</span>)</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> derivative sampleExpr </span>
<span class="op">&gt;</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="fl">3.0</span><span class=""> </span><span class="op">:*:</span><span class=""> ((</span><span class="dt">Const</span><span class=""> </span><span class="fl">2.0</span><span class=""> </span><span class="op">:*:</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="op">:^:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="fl">1.0</span><span class="">) </span><span class="op">:*:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="fl">1.0</span><span class="">) </span><span class="op">:+:</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="op">:^:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="fl">2.0</span>
<span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> ddx sampleExpr </span>
<span class="op">&gt;</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="fl">6.0</span><span class=""> </span><span class="op">:*:</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="co">-- 6x</span>
</code></pre></div><p>Another thing we can do is get a list of derivatives. The <code>iterate</code> method from the <code>Prelude</code> suits this type of thing perfectly – we can generate a (infinite!) list of derivatives of a function just by calling <code>iterate ddx</code>. Simple, expressive, and incredibly powerful.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> </span><span class="fu">take</span><span class=""> </span><span class="dv">3</span><span class=""> </span><span class="op">$</span><span class=""> ddxs</span>
<span class="">sampleExpr [</span><span class="dt">Const</span><span class=""> </span><span class="fl">3.0</span><span class=""> </span><span class="op">:*:</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="op">:</span><span class="">\</span><span class="op">^:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="fl">2.0</span><span class="">,</span><span class="dt">Const</span><span class=""> </span><span class="fl">6.0</span><span class=""> </span><span class="op">:*:</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class="">,</span><span class="dt">Const</span><span class=""> </span><span class="fl">6.0</span><span class="">] </span><span class="co">-- [3x\^2, 6x, 6] </span>
<span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> </span><span class="kw">let</span><span class=""> ds </span><span class="ot">=</span><span class=""> </span><span class="fu">take</span><span class=""> </span><span class="dv">4</span><span class=""> </span><span class="op">$</span><span class=""> ddxs sampleExpr</span>
<span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> </span><span class="fu">fmap</span><span class=""> (evalExpr </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="dv">2</span><span class="">) ds </span>
<span class="op">&gt;</span><span class=""> [</span><span class="fl">12.0</span><span class="">,</span><span class="fl">12.0</span><span class="">,</span><span class="fl">6.0</span><span class="">,</span><span class="fl">0.0</span><span class="">] </span>
</code></pre></div><p>We’re also able to grab the <span class="math inline">\(n^{th}\)</span> derivative of an expression. We could simply grab the <span class="math inline">\(n^{th}\)</span> term of <code>ddxs</code>, but we’ll do it without the wasted memory by repeatedly composing <code>ddx</code> <span class="math inline">\(n\)</span> times using <code>foldr1</code> and <code>replicate</code>.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> nthDerivative </span><span class="dv">2</span><span class=""> sampleExpr </span>
<span class="op">&gt;</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="fl">6.0</span>
</code></pre></div><p>There’s one last thing I want to touch on. Since it’s so simple to generate a list of derivatives of a function, why not use that to build functions’ Taylor series expansions?</p><h4 id="taylor-series-expansions">Taylor Series Expansions</h4><p>The Taylor series expansion of a function <span class="math inline">\(f(x)\)</span> about <span class="math inline">\(a\)</span> is defined as follows: <span class="math display">$$ \sum{n=1}^{\infty} \frac{f^{(n)}(a)}{n!} \cdot (x -
a)^n $$</span> The Maclaurin series expansion for a function is the Taylor series of a function with a = 0, and we will also implement that. Given that we can:</p><ol><li>Have multivariate expressions</li><li>Easily generate a list of derivatives</li></ol><p>We can actually find the Taylor series expansion of a function easily. Again, we can almost directly implement this function in Haskell, and evaluating it is no more difficult.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">taylor ::</span><span class=""> (</span><span class="dt">Floating</span><span class=""> a, </span><span class="dt">Eq</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Expr</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> [</span><span class="dt">Expr</span><span class=""> a]</span>
<span class="">taylor expr </span><span class="ot">=</span><span class=""> </span><span class="fu">fmap</span><span class=""> fullSimplify (</span><span class="fu">fmap</span><span class=""> series exprs)</span>
<span class="">  </span><span class="kw">where</span><span class=""> indices </span><span class="ot">=</span><span class=""> </span><span class="fu">fmap</span><span class=""> </span><span class="fu">fromIntegral</span><span class=""> [</span><span class="dv">1</span><span class="op">..</span><span class="">]</span>
<span class="">        derivs  </span><span class="ot">=</span><span class=""> </span><span class="fu">fmap</span><span class=""> (changeVars </span><span class="ch">&#39;a&#39;</span><span class="">) (ddxs expr)</span>
<span class="">          </span><span class="kw">where</span><span class=""> changeVars c </span><span class="ot">=</span><span class=""> mapVar (\_ </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Var</span><span class=""> c)</span>
<span class="">        facts   </span><span class="ot">=</span><span class=""> </span><span class="fu">fmap</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="op">$</span><span class=""> </span><span class="fu">scanl1</span><span class=""> (</span><span class="op">*</span><span class="">) indices</span>
<span class="">        exprs   </span><span class="ot">=</span><span class=""> </span><span class="fu">zip</span><span class=""> (</span><span class="fu">zipWith</span><span class=""> (</span><span class="op">:/:</span><span class="">) derivs facts) indices </span><span class="co">-- f^(n)(a)/n!</span>
<span class="">        series (expr, n) </span><span class="ot">=</span><span class=""> </span>
<span class="">          expr </span><span class="op">:*:</span><span class=""> ((</span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="op">:+:</span><span class=""> (negate&#39; </span><span class="op">$</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;a&#39;</span><span class="">)) </span><span class="op">:^:</span><span class=""> </span><span class="dt">Const</span><span class=""> n) </span><span class="co">-- f^(n)(a)/n! * (x - a)^n</span>

<span class="">maclaurin </span><span class="ot">=</span><span class=""> </span><span class="fu">fmap</span><span class=""> (fullSimplify </span><span class="op">.</span><span class=""> plugIn </span><span class="ch">&#39;a&#39;</span><span class=""> </span><span class="dv">0</span><span class="">) </span><span class="op">.</span><span class=""> taylor </span>

<span class="">evalTaylorWithPrecision a x prec </span><span class="ot">=</span><span class="">  </span>
<span class="">  </span><span class="fu">sum</span><span class=""> </span><span class="op">.</span><span class=""> </span><span class="fu">map</span><span class=""> (evalExpr&#39; </span><span class="op">.</span><span class=""> plugIn </span><span class="ch">&#39;x&#39;</span><span class=""> x </span><span class="op">.</span><span class=""> plugIn </span><span class="ch">&#39;a&#39;</span><span class=""> a) </span><span class="op">.</span><span class=""> </span><span class="fu">take</span><span class=""> prec </span><span class="op">.</span><span class=""> taylor</span>

<span class="">evalTaylor a x </span><span class="ot">=</span><span class=""> evalTaylorWithPrecision a x </span><span class="dv">100</span>
<span class="">        </span>
<span class="">evalMaclaurin </span><span class="ot">=</span><span class=""> evalTaylor </span><span class="dv">0</span>
<span class="">evalMacLaurinWithPrecision </span><span class="ot">=</span><span class=""> evalTaylorWithPrecision </span><span class="dv">0</span>
</code></pre></div><p>To produce a Taylor series, we need a couple of things:</p><ul><li>A list of derivatives</li><li>A list of indices</li><li>A list of factorials</li></ul><p>We create these three things in where clauses in the taylor declaration. indices are simple, <code>derivs</code> calculates a list of derivatives (using <code>mapVar</code> again to change all variables into <span class="math inline">\(a\)</span>s), and <code>facts</code> contains our factorials wrapped in <code>Const</code>s. We generate a list of <code>(expression, index)</code>s in <code>exprs</code>, and then map the “gluing” function <code>series</code> over <code>exprs</code> to produce a list of expressions in the series expansion. We then <code>fmap superSimplify</code> over the list in order to simplify down our expressions, and we get back a list of Taylor series terms for the given expression. The Maclaurin expansion can be defined as mentioned above in terms of the Taylor series, and again, we basically directly encode it (though we do have to re-simplify our expressions due to the plugging in of a variable). Let’s take a look at the Taylor expansion for <span class="math inline">\(f(x) = x\)</span>. We note that: <span class="math inline">\(f(a) = a\)</span>, <span class="math inline">\(f&#39;(a) = 1\)</span>, <span class="math inline">\(f&#39;&#39;(a) = 0\)</span>, and the rest of the derivatives will be 0. So our Taylor series terms <span class="math inline">\(T_n\)</span> should look something like: <span class="math inline">\(T_1 = \frac{a}{1} \cdot (x - a) = a \cdot (x-a)\)</span> <span class="math inline">\(T_2 = \frac{1}{2} \cdot (x-a)^2\)</span> <span class="math inline">\(T_3 = \frac{0}{6} \cdot
(x-a)^3 = 0\)</span> …and so on. Let’s take a look at what <code>taylor</code> produces:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> </span><span class="fu">take</span><span class=""> </span><span class="dv">3</span><span class=""> </span><span class="op">$</span><span class=""> taylor (</span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class="">) </span>
<span class="op">&gt;</span><span class=""> [</span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;a&#39;</span><span class=""> </span><span class="op">:*:</span><span class=""> (</span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="op">:+:</span><span class=""> </span><span class="dt">Const</span><span class=""> (</span><span class="op">-</span><span class="fl">1.0</span><span class="">) </span><span class="op">:*:</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;a&#39;</span><span class="">), </span>
<span class="op">--^</span><span class=""> a </span><span class="op">*</span><span class=""> (x</span><span class="op">-</span><span class="">a) </span>
<span class="">(</span><span class="dt">Const</span><span class=""> </span><span class="fl">1.0</span><span class=""> </span><span class="op">:/:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="fl">2.0</span><span class="">) </span><span class="op">:*:</span><span class=""> (</span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class=""> </span><span class="op">:+:</span><span class=""> </span><span class="dt">Const</span><span class=""> (</span><span class="op">-</span><span class="fl">1.0</span><span class="">) </span><span class="op">:*:</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;a&#39;</span><span class="">) </span><span class="op">:^:</span><span class=""> </span><span class="dt">Const</span><span class=""> </span><span class="fl">2.0</span><span class="">, </span>
<span class="op">--^</span><span class=""> </span><span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class=""> </span><span class="op">*</span><span class=""> (x</span><span class="op">-</span><span class="">a)</span><span class="op">^</span><span class="dv">2</span><span class=""> </span>
<span class="dt">Const</span><span class=""> </span><span class="fl">0.0</span><span class="">] </span>
</code></pre></div><p>This matches what we determined earlier. To evaluate a Taylor expression, we need a value for <span class="math inline">\(a\)</span>, a value for <span class="math inline">\(x\)</span>, and a specified number of terms for precision. We default this precision to 100 terms in the <code>evalTaylor</code> function, and the logic takes place in the <code>evalTaylorWithPrecision</code> function. In this function, we get the Taylor expansion, take the first <code>prec</code> terms, plug in <code>a</code> and <code>x</code> for all values of the function, and finally sum the terms. Maclaurin evaluation is again defined in terms of Taylor evaluation.</p><p>Taking a look at the above Taylor series expansion of <span class="math inline">\(f(x) = x\)</span>, there is only one term where a zero-valued <span class="math inline">\(a\)</span> will produce any output (namely <span class="math inline">\(\frac{1}{2} \cdot (x-a)^2\)</span>). So when we evaluate our Maclaurin series for this function at x, we should simply get back <span class="math inline">\(\frac{1}{2}x^2\)</span>. Let’s see how it works:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> evalMaclaurin </span><span class="dv">2</span><span class=""> (</span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class="">) </span>
<span class="op">&gt;</span><span class=""> </span><span class="fl">2.0</span><span class=""> </span><span class="co">--1/2 2\^2 = 1/2 * 4 = 2 </span>
<span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> evalMaclaurin </span><span class="dv">3</span><span class=""> (</span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class="">) </span>
<span class="op">&gt;</span><span class=""> </span><span class="fl">4.5</span><span class=""> </span><span class="co">-- 1/2 * 3^2 = 1/2 * 9 = 4.5 </span>
<span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> evalMaclaurin </span><span class="dv">10</span><span class=""> (</span><span class="dt">Var</span><span class=""> </span><span class="ch">&#39;x&#39;</span><span class="">) </span>
<span class="op">&gt;</span><span class=""> </span><span class="fl">50.0</span><span class=""> </span><span class="co">-- 1/2 * 10^2 = 1/2 * 100 = 50 </span>
</code></pre></div><p>Until next time,</p><p>Ben</p></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2013-05-01">2013-05-01</time></div></div></article><nav class="ui bottom attached segment deemphasized backlinks-container"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" data-inverted="" data-position="right center" data-tooltip="Tags: home"><a href=".">Ben Kovach</a></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc">Linking by tag: <code>Essays</code></div></li></ul></li></ul><a class="ui right ribbon label zettel-tag " href="search.html?tag=Essays" title="See all zettels tagged &#39;Essays&#39;">Essays</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Math" title="See all zettels tagged &#39;Math&#39;">Math</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Haskell" title="See all zettels tagged &#39;Haskell&#39;">Haskell</a><p></p></nav></div></div><div class="ui one column grid footer-version"><div class="center aligned column"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron" /></a></div></div></div></div></body></html>