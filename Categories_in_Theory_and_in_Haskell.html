<!DOCTYPE html></!DOCTYPE html><html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><title>Categories in Theory and in Haskell - Ben Kovach</title><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><style type="text/css">body{background-color:#eeeeee !important;font-family:"Ubuntu", serif !important}body .ui.container{font-family:"Ubuntu", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Kanit", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body div#neuron-theme-default-teal .zettel-content h1{background-color:rgba(0,181,173,0.1)}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a{color:#00b5ad}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#00b5ad}body div#neuron-theme-default-teal .deemphasized:hover div.item a:hover{color:#00b5ad !important}body div#neuron-theme-default-teal div#footnotes{border-top-color:#00b5ad}body div#neuron-theme-default-brown .zettel-content h1{background-color:rgba(165,103,63,0.1)}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a{color:#a5673f}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a5673f}body div#neuron-theme-default-brown .deemphasized:hover div.item a:hover{color:#a5673f !important}body div#neuron-theme-default-brown div#footnotes{border-top-color:#a5673f}body div#neuron-theme-default-red .zettel-content h1{background-color:rgba(219,40,40,0.1)}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a{color:#db2828}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#db2828}body div#neuron-theme-default-red .deemphasized:hover div.item a:hover{color:#db2828 !important}body div#neuron-theme-default-red div#footnotes{border-top-color:#db2828}body div#neuron-theme-default-orange .zettel-content h1{background-color:rgba(242,113,28,0.1)}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a{color:#f2711c}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#f2711c}body div#neuron-theme-default-orange .deemphasized:hover div.item a:hover{color:#f2711c !important}body div#neuron-theme-default-orange div#footnotes{border-top-color:#f2711c}body div#neuron-theme-default-yellow .zettel-content h1{background-color:rgba(251,189,8,0.1)}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a{color:#fbbd08}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#fbbd08}body div#neuron-theme-default-yellow .deemphasized:hover div.item a:hover{color:#fbbd08 !important}body div#neuron-theme-default-yellow div#footnotes{border-top-color:#fbbd08}body div#neuron-theme-default-olive .zettel-content h1{background-color:rgba(181,204,24,0.1)}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a{color:#b5cc18}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#b5cc18}body div#neuron-theme-default-olive .deemphasized:hover div.item a:hover{color:#b5cc18 !important}body div#neuron-theme-default-olive div#footnotes{border-top-color:#b5cc18}body div#neuron-theme-default-green .zettel-content h1{background-color:rgba(33,186,69,0.1)}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a{color:#21ba45}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#21ba45}body div#neuron-theme-default-green .deemphasized:hover div.item a:hover{color:#21ba45 !important}body div#neuron-theme-default-green div#footnotes{border-top-color:#21ba45}body div#neuron-theme-default-blue .zettel-content h1{background-color:rgba(33,133,208,0.1)}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a{color:#2185d0}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#2185d0}body div#neuron-theme-default-blue .deemphasized:hover div.item a:hover{color:#2185d0 !important}body div#neuron-theme-default-blue div#footnotes{border-top-color:#2185d0}body div#neuron-theme-default-violet .zettel-content h1{background-color:rgba(100,53,201,0.1)}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a{color:#6435c9}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#6435c9}body div#neuron-theme-default-violet .deemphasized:hover div.item a:hover{color:#6435c9 !important}body div#neuron-theme-default-violet div#footnotes{border-top-color:#6435c9}body div#neuron-theme-default-purple .zettel-content h1{background-color:rgba(163,51,200,0.1)}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a{color:#a333c8}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a333c8}body div#neuron-theme-default-purple .deemphasized:hover div.item a:hover{color:#a333c8 !important}body div#neuron-theme-default-purple div#footnotes{border-top-color:#a333c8}body div#neuron-theme-default-pink .zettel-content h1{background-color:rgba(224,57,151,0.1)}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a{color:#e03997}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#e03997}body div#neuron-theme-default-pink .deemphasized:hover div.item a:hover{color:#e03997 !important}body div#neuron-theme-default-pink div#footnotes{border-top-color:#e03997}body div#neuron-theme-default-grey .zettel-content h1{background-color:rgba(118,118,118,0.1)}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a{color:#767676}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#767676}body div#neuron-theme-default-grey .deemphasized:hover div.item a:hover{color:#767676 !important}body div#neuron-theme-default-grey div#footnotes{border-top-color:#767676}body div#neuron-theme-default-black .zettel-content h1{background-color:rgba(27,28,29,0.1)}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a{color:#1b1c1d}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#1b1c1d}body div#neuron-theme-default-black .deemphasized:hover div.item a:hover{color:#1b1c1d !important}body div#neuron-theme-default-black div#footnotes{border-top-color:#1b1c1d}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.84999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f8f8f8}body div.zettel-view .zettel-content pre{padding:0.5em 0.5em 0.5em 0.5em;overflow:auto;max-width:100%}body div.zettel-view .zettel-content div.pandoc-code{margin-left:auto;margin-right:auto}body div.zettel-view .zettel-content div.pandoc-code pre{background-color:#f8f8f8}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.backlinks-container{background-color:#eeeeee !important}body ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body ul.context-list > li{list-style-type:lower-roman}body span.zettel-link-container span.zettel-link a{font-weight:bold;text-decoration:none}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}body nav.top-menu{padding-top:1em;padding-bottom:1em;justify-content:center;text-align:center}body nav.top-menu > *{padding-left:0px;padding-right:0px}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}</style><link href="https://fonts.googleapis.com/css?family=Kanit|Ubuntu|Roboto+Mono&amp;display=swap" rel="stylesheet" /><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta content="Ben Kovach" name="author" /><meta content="This is the first post in a series that I hope to expand over time
regarding notions in category theory and how they manifest in the
haskell programming language.
" name="description" /><link href="https://kovach.me/Categories_in_Theory_and_in_Haskell.html" rel="canonical" /><meta content="Categories in Theory and in Haskell" property="og:title" /><meta content="Ben Kovach" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[]</script><style type="text/css">pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style></head><body><div class="ui fluid container" id="neuron-theme-default-blue"><nav class="top-menu"><div class="ui inverted compact neuron icon menu blue"><a class="left item" href="." title="Home"><i class="home icon"></i></a><a class="left item" href="search.html" title="Search Zettels"><i class="search icon"></i></a><a class="center item" href="https://github.com/5outh/zettelkasten/edit/master/Categories in Theory and in Haskell.md" title="Edit this Zettel"><i class="edit icon"></i></a><a class="right item" href="z-index.html" title="All Zettels (z-index)"><i class="tree icon"></i></a></div></nav><div class="ui text container" id="zettel-container" style="position: relative"><div id="zettel-container-anchor" style="position: absolute; top: -24px; left: 0"></div><div class="zettel-view"><article class="ui raised attached segment zettel-content"><h1>Categories in Theory and in Haskell</h1><div class="pandoc"><h2 id="overview">Overview</h2><p>This is the first post in a series that I hope to expand over time regarding notions in category theory and how they manifest in the haskell programming language.</p><p>Category theory is extremely general; its language is useful in recognizing structure and unifying mathematical concepts that don’t seem related at first glance. It’s a wonderful tool for gaining intuition about wildly different things in one fell swoop, which makes it a lot of fun to explore.</p><p>On the other hand, haskell is an increasingly-widely-used, purely functional programming language with some obvious roots in category theory. A lot of the bizarre-sounding words haskellers use on a daily basis are derived from category theory (or other branches of mathematics that category theory generalizes). However, mapping from category theory to haskell is sometimes nontrivial, and it can be hard to see the connection.</p><p>I think that learning haskell should be a tool for understanding category theory and vice versa. This post, and possibly other future posts, will hopefully shed some light on the explicit translations between category theory language and haskell. This is not necessarily intended to be an introduction to category theory or haskell, and I don’t want to be too pedantic about definitions. however, I hope to incite an intuitive understanding about the basics of category theory and its translation to haskell.</p><h2 id="the-category-intuitively">The category (intuitively)</h2><p>A category is a type of mathematical object. For the uninitiated, one of the simplest examples of a mathematical object is the set; a collection of “things” that doesn’t contain duplicates. Examples are:</p><ul><li>The set of natural numbers <span class="math inline">\(\{0..\infty\}\)</span></li><li>The set of all humans living in Europe</li><li>The set of all board games designed in the 1980s</li></ul><p>Sets have a very general structure, so many traditional mathematical objects add structure <em>on top of</em> sets in order to find more interesting insights.</p><p>A category* is one of these objects. Intuitively, a category is a structure containing a bunch of “things” along with a way to move between those things.</p><small>
\* Technically, _small_ category.
</small>
<h2 id="the-category-in-theory">The category (in theory)</h2><p>The (semi)formal* definition of a category is as follows:</p><p>A category C consists of two things:</p><ul><li>A collection <span class="math inline">\(C_0\)</span> of <em>objects</em>.</li><li>A collection <span class="math inline">\(C_1\)</span> of <em>morphisms</em>, with a <em>source</em> and <em>target</em> in <span class="math inline">\(C_0\)</span>. We’ll consider an element of this set to look like <code>f : a -&gt; b</code>, where <code>a</code> is called the <em>source</em> of the morphism, and <code>b</code> is called its <em>target</em>.</li><li>A special morphism in <span class="math inline">\(id : C_0 \rightarrow C_1\)</span>, which assigns to each object <span class="math inline">\(x
\in C_0\)</span> a morphism <span class="math inline">\(id_x\)</span> following the unit laws listed below.</li><li>A composition operator <span class="math inline">\(\circ\)</span>, which assigns, to any pair of morphisms <code>f : a -&gt; b</code> and <code>g : b -&gt; c</code>, a composite morphism <span class="math inline">\(g \circ f\)</span> <code>: a -&gt; c</code> (Note that the source of <code>g</code> is the target of <code>f</code>).</li></ul><p>The following are also necessarily true of a category:</p><ul><li>Composition is associative: <span class="math inline">\((h \circ g) \circ f = h \circ (g \circ f)\)</span> for <code>f : c -&gt; d, g : b -&gt; c, h : a -&gt; b</code> in <span class="math inline">\(C_0\)</span>.</li><li>Composition satisfies the left and right unit laws: <span class="math inline">\(id_y \circ f = f = f
\circ id_x\)</span> for all morphisms <span class="math inline">\(s\)</span> in <span class="math inline">\(C_0\)</span>.</li></ul><p>Intuitively, <span class="math inline">\(id\)</span> maps each object back to itself. However, when the structure of a category’s morphisms doesn’t look like a pure function, this definition is not exact. Neither the structure of objects, nor the structure of morphisms, is static across all categories. Hence we cannot say exactly what <span class="math inline">\(id\)</span> or <span class="math inline">\(\circ\)</span> <em>does</em>; we can only say how they should behave when they appear in a mathematical expression using a certain category.</p><small>
\* Slightly handwavy, but formal enough to get the point across for our purposes!
  For two _full_ definitions, see [nlab's page on categories](https://ncatlab.org/nlab/show/category#definitions).
</small>
<p>Here’s an example:</p><p><strong>Set</strong> is the category consisting of Sets as objects and functions between those sets as morphisms. Two objects in this category are the set of Natural numbers <span class="math inline">\(\mathbb{N}\)</span> and the set of Boolean values <span class="math inline">\(Bool = \{True, False\}\)</span>. The function <span class="math inline">\(odd : \mathbb{N} \rightarrow Bool\)</span> which takes each natural number to its truth value of whether it is odd or not is a morphism in this category.</p><p>Some other examples of categories are:</p><ul><li>The <strong>free category</strong> generated by a directed graph, with nodes as objects and arrows between nodes as morphisms.</li><li><strong>Hask</strong>, the category of haskell types and functions, which we will discuss next.</li><li><strong>Grp</strong>, the category with groups as objects and group homomorphisms as arrows.*</li></ul><small>
* It's hard to find examples that aren't deeply entrenched in mathematics;
  sorry!
</small>
<h2 id="hask">Hask</h2><p>Before we talk about encoding categories in Haskell, I’d like to briefly talk about Haskell’s very own category, <strong>Hask</strong>.</p><p><strong>Hask</strong> is the category in which:</p><ul><li>Members of Haskell’s types are objects</li><li>Regular Haskell functions (<code>a -&gt; b</code>) are morphisms.</li></ul><p><code>id :: a -&gt; a</code> is the <span class="math inline">\(id\)</span> morphism, and regular function composition with <code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code> is morphism composition in <strong>Hask</strong>.</p><p><strong>Hask</strong> is a legitimate category, but we have to be specific about what <code>undefined</code> means. More on that <a href="https://wiki.haskell.org/Hask">on haskell wiki</a>. Note that <strong>Hask</strong> is a category whether or not we’re speaking about it internally or externally; mentions of <strong>Hask</strong> are not required to appear in the context of haskell, which is interesting!</p><h2 id="the-category-in-haskell">The category (in haskell)</h2><p>In haskell, we typically use typeclasses to encode common functionality between various structures, which is exactly what we will do to encode category-theoretical categories. Here is the typeclass definition for <code>Category</code>:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">class</span><span class=""> </span><span class="dt">Category</span><span class=""> cat </span><span class="kw">where</span>
<span class="">  </span><span class="fu">id</span><span class=""> </span><span class="op">:</span><span class=""> cat a a</span>
<span class="">  (</span><span class="op">.</span><span class="">) </span><span class="op">:</span><span class=""> cat b c </span><span class="ot">-&gt;</span><span class=""> cat a b </span><span class="ot">-&gt;</span><span class=""> cat a c </span>
</code></pre></div><p>We’ll talk more about this in a minute. First, let’s look at the most straight-forward example of a <code>Category</code>, the instance for <code>(-&gt;)</code> (Turn on the <code>InstanceSigs</code> GHC extension to get this to compile):</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">instance</span><span class=""> </span><span class="dt">Category</span><span class=""> (</span><span class="ot">-&gt;</span><span class="">) </span><span class="kw">where</span>
<span class="ot">  id ::</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> a </span><span class="co">-- or (-&gt;) a a</span>
<span class="">  </span><span class="fu">id</span><span class=""> x </span><span class="ot">=</span><span class=""> x</span>

<span class="ot">  (.) ::</span><span class=""> (b </span><span class="ot">-&gt;</span><span class=""> c) </span><span class="ot">-&gt;</span><span class=""> (a </span><span class="ot">-&gt;</span><span class=""> b) </span><span class="ot">-&gt;</span><span class=""> (a </span><span class="ot">-&gt;</span><span class=""> c)</span>
<span class="">      </span><span class="co">-- or ((-&gt;) b c) -&gt; ((-&gt;) a b) -&gt; ((-&gt;) a c)</span>
<span class="">  (f </span><span class="op">.</span><span class=""> g) x </span><span class="ot">=</span><span class=""> f (g x) </span>
</code></pre></div><p>This instance represents <strong>Hask</strong>. Another common <code>Category</code> instance we commonly encounter as haskell programmers is the one for <code>Kleisli</code> arrows, which we see quite a bit when writing monadic code:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">newtype</span><span class=""> </span><span class="dt">Kleisli</span><span class=""> m a b </span><span class="ot">=</span><span class=""> </span><span class="dt">Kleisli</span><span class=""> {</span><span class="ot"> runKleisli ::</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> m b }</span>

<span class="kw">instance</span><span class=""> </span><span class="dt">Monad</span><span class=""> m </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Category</span><span class=""> (</span><span class="dt">Kleisli</span><span class=""> m) </span><span class="kw">where</span>
<span class="ot">  id ::</span><span class=""> </span><span class="dt">Kleisli</span><span class=""> m a a </span>
<span class="">  </span><span class="fu">id</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">Kleisli</span><span class=""> </span><span class="fu">return</span>

<span class="ot">  (.) ::</span><span class=""> </span><span class="dt">Kleisli</span><span class=""> m b c </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Kleisli</span><span class=""> m a b </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Kleisli</span><span class=""> m a c</span>
<span class="">  (</span><span class="dt">Kleisli</span><span class=""> f) </span><span class="op">.</span><span class=""> (</span><span class="dt">Kleisli</span><span class=""> g) </span><span class="ot">=</span><span class=""> </span><span class="dt">Kleisli</span><span class=""> </span><span class="op">$</span><span class=""> \x </span><span class="ot">-&gt;</span><span class=""> (f </span><span class="op">&lt;=&lt;</span><span class=""> g) x</span>
</code></pre></div><p>Recall that:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="fu">return</span><span class="ot"> ::</span><span class=""> </span><span class="dt">Monad</span><span class=""> m </span><span class="ot">=&gt;</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> m a </span>
<span class="co">-- The Kleisli fish operator &lt;=&lt; comes from Control.Monad.</span>
<span class="ot">(&lt;=&lt;) ::</span><span class=""> </span><span class="dt">Monad</span><span class=""> m </span><span class="ot">=&gt;</span><span class=""> (b </span><span class="ot">-&gt;</span><span class=""> m c) </span><span class="ot">-&gt;</span><span class=""> (a </span><span class="ot">-&gt;</span><span class=""> m b) </span><span class="ot">-&gt;</span><span class=""> (a </span><span class="ot">-&gt;</span><span class=""> m c)</span>
</code></pre></div><p>and it might be easier to see where that instance comes from. We won’t prove that these two instances follow the category laws here; the important thing for our purposes is that these instances follow the pattern. Proving that this instance follows the category laws through equational reasoning is a nice exercise, though.</p><p>At this point, it may feel like there are some holes. In the mathematical interpretation, we construct categories by explicitly providing both objects of a category and its morphisms. It’s not totally obvious where those come up when representing categories in haskell. So, where’s the connection?</p><h2 id="the-connection">The connection</h2><p>Objects of a <code>Category</code> in haskell are types. The typeclass variable <code>cat</code> describes the type (see aside below) of morphisms in our category. Specifically, the sources and targets of our morphisms are hidden in the type declaration for the morphisms we’re declaring a category instance for. In <code>(-&gt;)</code>, the source and target can be any haskell data type. For a morphism in <code>Kleisli</code>, however, the <em>source</em> can be any haskell data type, but the <em>target</em> of our morphisms must be something with the structure <code>m a</code> for some <code>m</code>. This lets us describe in some sense the structure of a morphism in the category, though it does not give us all laws for free (Try encoding <strong>Grp</strong>, for instance).</p><p>In typeclass instances for <code>Category</code>, we develop the laws stating that we must have identity and composition operators that respect the structure of our objects and categories. Haskell’s typechecker helps us confirm that some of the category laws hold by construction. If we can’t find something of type <code>cat a a</code>, we don’t have an <span class="math inline">\(id\)</span>. If we can’t find a typechecking instance for <code>(.)</code>, we can’t ensure that sources and targets match up when composing morphisms. This may not always give us law-abiding instances for free, but we can certainly be guided by the typechecker.</p><hr />
<h3 id="aside-types">Aside: types</h3><p>Types are themselves a kind of mathematical structure in the same vein as sets. The main difference is that types are <em>constrained</em> to a certain subset of values; with (mathematical) sets, anything goes. Haskell’s type definitions define a subset of <em>values</em> that are valid inhabitants (members) of a type. The type itself can be viewed in some sense as the set of all of its inhabitants. When we say a value <span class="math inline">\(v\)</span> has type <span class="math inline">\(\tau\)</span>, with this definition we are saying that <span class="math inline">\(v \in \tau\)</span>.</p><hr />
<p>(These are not the only categories we can encode in Haskell; they are just two common examples.)</p><h2 id="takeaway">Takeaway</h2><p>It is possible to encode a category in haskell, but it doesn’t look exactly the same as laying out its definition on paper in a mathematical setting. In particular:</p><ul><li>A category <span class="math inline">\(C\)</span> is defined in haskell by providing the type (structure) of morphisms in <span class="math inline">\(C\)</span>, instead of explicitly stating its objects and morphisms.</li><li>Objects of all categories defined in haskell are types expressible by the haskell type system. In the whole world of mathematics, objects can be much broader.</li><li>Typechecking implementations of <span class="math inline">\(id\)</span> and <span class="math inline">\(\circ\)</span> must be provided for all <code>Category</code> instances, which guides us towards law-abiding implementations.</li></ul></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2016-06-01">2016-06-01</time></div></div></article><nav class="ui bottom attached segment deemphasized backlinks-container"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" data-inverted="" data-position="right center" data-tooltip="Tags: home"><a href=".">Ben Kovach</a></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc">Linking by tag: <code>Essays</code></div></li></ul></li></ul><a class="ui right ribbon label zettel-tag " href="search.html?tag=Haskell" title="See all zettels tagged &#39;Haskell&#39;">Haskell</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Category Theory" title="See all zettels tagged &#39;Category Theory&#39;">Category Theory</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Essays" title="See all zettels tagged &#39;Essays&#39;">Essays</a><p></p></nav></div></div><div class="ui one column grid footer-version"><div class="center aligned column"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron" /></a></div></div></div></div></body></html>