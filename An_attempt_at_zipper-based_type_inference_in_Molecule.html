<!DOCTYPE html></!DOCTYPE html><html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><title>An attempt at zipper-based type inference in Molecule - Ben Kovach</title><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><style type="text/css">body{background-color:#eeeeee !important;font-family:"Ubuntu", serif !important}body .ui.container{font-family:"Ubuntu", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Kanit", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body div#neuron-theme-default-teal .zettel-content h1{background-color:rgba(0,181,173,0.1)}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a{color:#00b5ad}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#00b5ad}body div#neuron-theme-default-teal .deemphasized:hover div.item a:hover{color:#00b5ad !important}body div#neuron-theme-default-teal div#footnotes{border-top-color:#00b5ad}body div#neuron-theme-default-brown .zettel-content h1{background-color:rgba(165,103,63,0.1)}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a{color:#a5673f}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a5673f}body div#neuron-theme-default-brown .deemphasized:hover div.item a:hover{color:#a5673f !important}body div#neuron-theme-default-brown div#footnotes{border-top-color:#a5673f}body div#neuron-theme-default-red .zettel-content h1{background-color:rgba(219,40,40,0.1)}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a{color:#db2828}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#db2828}body div#neuron-theme-default-red .deemphasized:hover div.item a:hover{color:#db2828 !important}body div#neuron-theme-default-red div#footnotes{border-top-color:#db2828}body div#neuron-theme-default-orange .zettel-content h1{background-color:rgba(242,113,28,0.1)}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a{color:#f2711c}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#f2711c}body div#neuron-theme-default-orange .deemphasized:hover div.item a:hover{color:#f2711c !important}body div#neuron-theme-default-orange div#footnotes{border-top-color:#f2711c}body div#neuron-theme-default-yellow .zettel-content h1{background-color:rgba(251,189,8,0.1)}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a{color:#fbbd08}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#fbbd08}body div#neuron-theme-default-yellow .deemphasized:hover div.item a:hover{color:#fbbd08 !important}body div#neuron-theme-default-yellow div#footnotes{border-top-color:#fbbd08}body div#neuron-theme-default-olive .zettel-content h1{background-color:rgba(181,204,24,0.1)}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a{color:#b5cc18}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#b5cc18}body div#neuron-theme-default-olive .deemphasized:hover div.item a:hover{color:#b5cc18 !important}body div#neuron-theme-default-olive div#footnotes{border-top-color:#b5cc18}body div#neuron-theme-default-green .zettel-content h1{background-color:rgba(33,186,69,0.1)}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a{color:#21ba45}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#21ba45}body div#neuron-theme-default-green .deemphasized:hover div.item a:hover{color:#21ba45 !important}body div#neuron-theme-default-green div#footnotes{border-top-color:#21ba45}body div#neuron-theme-default-blue .zettel-content h1{background-color:rgba(33,133,208,0.1)}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a{color:#2185d0}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#2185d0}body div#neuron-theme-default-blue .deemphasized:hover div.item a:hover{color:#2185d0 !important}body div#neuron-theme-default-blue div#footnotes{border-top-color:#2185d0}body div#neuron-theme-default-violet .zettel-content h1{background-color:rgba(100,53,201,0.1)}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a{color:#6435c9}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#6435c9}body div#neuron-theme-default-violet .deemphasized:hover div.item a:hover{color:#6435c9 !important}body div#neuron-theme-default-violet div#footnotes{border-top-color:#6435c9}body div#neuron-theme-default-purple .zettel-content h1{background-color:rgba(163,51,200,0.1)}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a{color:#a333c8}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a333c8}body div#neuron-theme-default-purple .deemphasized:hover div.item a:hover{color:#a333c8 !important}body div#neuron-theme-default-purple div#footnotes{border-top-color:#a333c8}body div#neuron-theme-default-pink .zettel-content h1{background-color:rgba(224,57,151,0.1)}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a{color:#e03997}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#e03997}body div#neuron-theme-default-pink .deemphasized:hover div.item a:hover{color:#e03997 !important}body div#neuron-theme-default-pink div#footnotes{border-top-color:#e03997}body div#neuron-theme-default-grey .zettel-content h1{background-color:rgba(118,118,118,0.1)}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a{color:#767676}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#767676}body div#neuron-theme-default-grey .deemphasized:hover div.item a:hover{color:#767676 !important}body div#neuron-theme-default-grey div#footnotes{border-top-color:#767676}body div#neuron-theme-default-black .zettel-content h1{background-color:rgba(27,28,29,0.1)}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a{color:#1b1c1d}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#1b1c1d}body div#neuron-theme-default-black .deemphasized:hover div.item a:hover{color:#1b1c1d !important}body div#neuron-theme-default-black div#footnotes{border-top-color:#1b1c1d}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.84999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f8f8f8}body div.zettel-view .zettel-content pre{padding:0.5em 0.5em 0.5em 0.5em;overflow:auto;max-width:100%}body div.zettel-view .zettel-content div.pandoc-code{margin-left:auto;margin-right:auto}body div.zettel-view .zettel-content div.pandoc-code pre{background-color:#f8f8f8}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.backlinks-container{background-color:#eeeeee !important}body ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body ul.context-list > li{list-style-type:lower-roman}body span.zettel-link-container span.zettel-link a{font-weight:bold;text-decoration:none}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}body nav.top-menu{padding-top:1em;padding-bottom:1em;justify-content:center;text-align:center}body nav.top-menu > *{padding-left:0px;padding-right:0px}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}</style><link href="https://fonts.googleapis.com/css?family=Kanit|Ubuntu|Roboto+Mono&amp;display=swap" rel="stylesheet" /><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta content="Ben Kovach" name="author" /><meta content="I recently designed a very small programming language, Molecule.
Molecule is a slight extension of the simply typed lambda calculus
(STLC) that supports type inference. It is mostly a contained experiment
on how to implement type inference in an STLC-like language.
" name="description" /><link href="https://kovach.me/An_attempt_at_zipper-based_type_inference_in_Molecule.html" rel="canonical" /><meta content="An attempt at zipper-based type inference in Molecule" property="og:title" /><meta content="Ben Kovach" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[]</script><style type="text/css">pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style></head><body><div class="ui fluid container" id="neuron-theme-default-blue"><nav class="top-menu"><div class="ui inverted compact neuron icon menu blue"><a class="left item" href="." title="Home"><i class="home icon"></i></a><a class="left item" href="search.html" title="Search Zettels"><i class="search icon"></i></a><a class="center item" href="https://github.com/5outh/zettelkasten/edit/master/An attempt at zipper-based type inference in Molecule.md" title="Edit this Zettel"><i class="edit icon"></i></a><a class="right item" href="z-index.html" title="All Zettels (z-index)"><i class="tree icon"></i></a></div></nav><div class="ui text container" id="zettel-container" style="position: relative"><div id="zettel-container-anchor" style="position: absolute; top: -24px; left: 0"></div><div class="zettel-view"><article class="ui raised attached segment zettel-content"><h1>An attempt at zipper-based type inference in Molecule</h1><div class="pandoc"><h3 id="prelude">Prelude</h3><p>I recently designed a very small programming language, <a href="https://github.com/5outh/Molecule">Molecule</a>. Molecule is a slight extension of the <a href="http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simply typed lambda calculus (STLC)</a> that supports type inference. It is mostly a contained experiment on how to implement type inference in an STLC-like language.</p><p>In this blog post, I want to talk about my experience with Molecule and its static type checking and inference mechanism, which works for <em>most</em> valid programs. I do not know if this approach can be modified to work for <em>all</em> valid programs (and indeed this is a problem), but I think it’s worth talking about regardless.</p><p>Molecule and its REPL, <code>mi</code>, can be downloaded <a href="https://github.com/5outh/Molecule">from GitHub</a>, if you’d like to play with it.</p><h3 id="syntax">Syntax</h3><p>Molecule’s syntax tries to emulate the mathematical notation used in the lambda calculus, without explicit type annotations (which aren’t even allowed syntactically). A valid program can be one of the following expressions (informally):</p><ul><li><code>Int</code> literals</li><li><code>Boolean</code> literals (<code>t</code> and <code>f</code>)</li><li>Addition (<code>1 + 2</code>)</li></ul><p>- Boolean Or (<code>f | t</code>)</p><ul><li>Lambda abstractions (<code>\x. x + x</code>), and</li><li>Function application (<code>(\x.x) 80</code>)</li></ul><p>Expressions can have type <code>Int</code>, <code>Bool</code>, or any function type between types, e.g. <code>Int -&gt; Bool</code>. Expressions are monomorphic, meaning they cannot take more than one value. For a quick example, the polymorphic identity function <code>\x.x</code> has no type in Molecule – only applied to another expression can it take on a type. <code>(\x.x) 10</code>, for example, has type <code>Int</code>.</p><p>The type inference mechanism that I will be describing never produces the <em>wrong</em> type for a Molecule expression, but it fails to realize that some expressions can be typed at all. The following expression, for example:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="">((\x</span><span class="op">.</span><span class="">x) (\x</span><span class="op">.</span><span class="">x)) f</span>
</code></pre></div><p>should have type <code>Bool</code>; however, Molecule’s type checker cannot unify its type.</p><h3 id="type-inference-in-molecule">Type Inference in Molecule</h3><p>When designing a slightly more ambitious PL, I was writing a naïve type inferencer and hit the point where I was pattern matching on non-leaf expression constructors in order to determine the types of the leaves. At a basic level, there was an <code>Expr</code> data type akin to:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">data</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span><span class="ot">=</span><span class=""> </span>
<span class="">    </span><span class="dt">Var</span><span class=""> </span><span class="dt">String</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">PInt</span><span class=""> </span><span class="dt">Int</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span><span class="op">:+:</span><span class=""> </span><span class="dt">Expr</span>
<span class="">   </span><span class="co">-- ... and so on</span>
</code></pre></div><p>And I was pattern matching against, for example <code>(Var &quot;x&quot; :+: a)</code> as well as <code>(a :+: Var &quot;x&quot;)</code> in order to determine that <code>x</code> was an <code>Int</code>. As you can imagine, this got tedious quickly. I wanted to be able to have some function <code>infer :: Expr -&gt; Type</code> such that <code>infer (Var x)</code> would spit out the type for <code>x</code> in the context of its expression. After narrowing down the information that I actually needed to typecheck a <code>Var</code>, I realized all that was needed in order to infer the type of an expression was information about where the <code>Var</code> came from one level higher in the AST. For example, in the expression <code>(Var &quot;x&quot; :+: a)</code>, just knowing that <code>Var &quot;x&quot;</code> came from a <code>:+:</code> expression is enough to determine that <code>x : Int</code>, and similarly for other types of expressions.</p><p>Let’s dive into the actual definitions of Molecule’s data types in order to talk about how this works concretely in practice.</p><p>Types are simple, as described above. <code>TLam</code> represents function types (<code>Int -&gt; Bool === TLam TInt TBool</code>).</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">data</span><span class=""> </span><span class="dt">MoleculeType</span><span class=""> </span><span class="ot">=</span>
<span class="">    </span><span class="dt">TBool</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">TInt</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">TLam</span><span class=""> </span><span class="dt">MoleculeType</span><span class=""> </span><span class="dt">MoleculeType</span>
<span class="">    </span><span class="kw">deriving</span><span class=""> </span><span class="dt">Eq</span>
</code></pre></div><p>Values can be <code>Bool</code>s, <code>Int</code>s, or function values with an expression environment (mappings from variables in scope to expressions), the name of the argument it takes, and an expression body.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">type</span><span class=""> </span><span class="dt">Name</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">String</span>
<span class="kw">type</span><span class=""> </span><span class="dt">Env</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">Map</span><span class=""> </span><span class="dt">Name</span><span class=""> </span><span class="dt">MoleculeValue</span>

<span class="kw">data</span><span class=""> </span><span class="dt">MoleculeValue</span><span class=""> </span><span class="ot">=</span>
<span class="">    </span><span class="dt">VBool</span><span class=""> </span><span class="dt">Bool</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">VInt</span><span class=""> </span><span class="dt">Int</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">VLam</span><span class=""> </span><span class="dt">Env</span><span class=""> </span><span class="dt">Name</span><span class=""> </span><span class="dt">MoleculeExpr</span>
</code></pre></div><p>Expressions are represented as you might expect. <code>EAbs</code> represents a lambda abstraction, <code>EApp</code> function application, and <code>:+:</code> and <code>:|:</code> correspond to addition and boolean <code>or</code>, respectively.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">data</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class=""> </span><span class="ot">=</span>
<span class="">    </span><span class="dt">EVar</span><span class=""> </span><span class="dt">Name</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">ETrue</span><span class=""> </span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">EFalse</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">EInt</span><span class=""> </span><span class="dt">Int</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">EAbs</span><span class=""> </span><span class="dt">Name</span><span class=""> </span><span class="dt">MoleculeExpr</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">EApp</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class=""> </span><span class="dt">MoleculeExpr</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class=""> </span><span class="op">:+:</span><span class=""> </span><span class="dt">MoleculeExpr</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class=""> </span><span class="op">:|:</span><span class=""> </span><span class="dt">MoleculeExpr</span>
<span class="">    </span><span class="kw">deriving</span><span class=""> </span><span class="dt">Eq</span><span class=""> </span>
</code></pre></div><p>Here’s the key data type we need in order to keep track of the expression we’re coming from when we hit <code>Var</code> values in the type inferencer. Each of these <code>Crumb</code>s tag the expression one level higher and carry along all information in it that isn’t already present in the expression currently being expected. This is one of the pieces of a <a href="http://learnyouahaskell.com/zippers">zipper</a> for the Molecule AST.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">data</span><span class=""> </span><span class="dt">MoleculeCrumb</span><span class=""> </span><span class="ot">=</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">CPlus</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class="">   </span><span class="co">-- Came from +</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">COr</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class="">     </span><span class="co">-- Came from |</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">CAbs</span><span class=""> </span><span class="dt">Name</span><span class="">            </span><span class="co">-- Came from a lambda abstraction</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">CApp1</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class="">   </span><span class="co">-- Came from first arg of application</span>
<span class="">  </span><span class="op">|</span><span class=""> </span><span class="dt">CApp2</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class="">   </span><span class="co">-- Came from second arg of application</span>
<span class="">    </span><span class="kw">deriving</span><span class=""> (</span><span class="dt">Show</span><span class="">, </span><span class="dt">Eq</span><span class="">)</span>
</code></pre></div><p>We use a basic monad transformer stack to represent the type of the type checker.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">type</span><span class=""> </span><span class="dt">TypeEnv</span><span class="">     </span><span class="ot">=</span><span class=""> </span><span class="dt">M.Map</span><span class=""> </span><span class="dt">Name</span><span class=""> </span><span class="dt">MoleculeType</span>
<span class="kw">type</span><span class=""> </span><span class="dt">Scope</span><span class="">       </span><span class="ot">=</span><span class=""> </span><span class="dt">S.Set</span><span class=""> </span><span class="dt">Name</span>
<span class="kw">type</span><span class=""> </span><span class="dt">Typechecker</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">ExceptT</span><span class=""> </span><span class="dt">MoleculeError</span><span class=""> (</span><span class="dt">ReaderT</span><span class=""> (</span><span class="dt">Maybe</span><span class=""> </span><span class="dt">MoleculeCrumb</span><span class="">, </span><span class="dt">Scope</span><span class="">) (</span><span class="dt">StateT</span><span class=""> </span><span class="dt">TypeEnv</span><span class=""> </span><span class="dt">Identity</span><span class="">))</span>
</code></pre></div><p><code>TypeEnv</code>s are maps from variable names to types, and a <code>Scope</code> is a list of variable names in scope. The typechecker has access to 3 basic (monadic) effects:</p><ol><li>Error production, via <code>ExceptT MoleculeError</code></li><li>Threading variable scope and a crumb through the computation, via <code>ReaderT (Maybe MoleculeCrumb, Scope)</code>, and</li><li>Access to a mutable type environment, via <code>StateT TypeEnv Identity</code>.</li></ol><p>Note that we don’t need a “full” zipper here, since we only care about the <em>single</em> expression that the variable came from, not the entire path from the AST root. This is all we need to implement a relatively robust type inference/checking mechanism for Molecule. The <em>inference</em> part of type checking takes place in the following branch of the <code>check</code> function, which accepts an <code>EVar</code> (Note: this is modified for brevity; in practice, more specific type errors are thrown for failing expressions).</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">check ::</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Typechecker</span><span class=""> </span><span class="dt">MoleculeType</span>
<span class="">check (</span><span class="dt">EVar</span><span class=""> name) </span><span class="ot">=</span><span class=""> </span><span class="kw">do</span>
<span class="">  </span><span class="kw">let</span><span class=""> addBinding name typ </span><span class="ot">=</span><span class=""> modify (M.insert name typ) </span><span class="op">&gt;&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> typ</span>
<span class="">      typeError </span><span class="ot">=</span><span class=""> throwError </span><span class="op">.</span><span class=""> </span><span class="dt">TypeError</span>
<span class="">  (crumb, scope) </span><span class="ot">&lt;-</span><span class=""> ask</span>
<span class="">  </span><span class="kw">if</span><span class=""> S.notMember name scope</span>
<span class="">  </span><span class="kw">then</span><span class=""> typeError </span><span class="op">$</span><span class=""> </span><span class="st">&quot;variable not in scope: &quot;</span><span class=""> </span><span class="op">++</span><span class=""> name</span>
<span class="">  </span><span class="kw">else</span><span class=""> </span><span class="kw">do</span>
<span class="">    env </span><span class="ot">&lt;-</span><span class=""> get</span>
<span class="">    </span><span class="kw">case</span><span class=""> M.lookup name env </span><span class="kw">of</span>
<span class="">      </span><span class="dt">Nothing</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">case</span><span class=""> crumb </span><span class="kw">of</span>
<span class="">        </span><span class="dt">Just</span><span class=""> x </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">case</span><span class=""> x </span><span class="kw">of</span>
<span class="">          </span><span class="dt">CPlus</span><span class=""> _ </span><span class="ot">-&gt;</span><span class=""> addBinding name </span><span class="dt">TInt</span>
<span class="">          </span><span class="dt">COr</span><span class="">   _ </span><span class="ot">-&gt;</span><span class=""> addBinding name </span><span class="dt">TBool</span>
<span class="">          </span><span class="dt">CAbs</span><span class=""> nm </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">case</span><span class=""> M.lookup nm env </span><span class="kw">of</span>
<span class="">            </span><span class="dt">Just</span><span class=""> t  </span><span class="ot">-&gt;</span><span class=""> addBinding name t</span>
<span class="">          </span><span class="dt">CApp2</span><span class=""> e </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">do</span>
<span class="">            t </span><span class="ot">&lt;-</span><span class=""> check e</span>
<span class="">            </span><span class="kw">case</span><span class=""> t </span><span class="kw">of</span>
<span class="">              </span><span class="dt">TLam</span><span class=""> v _ </span><span class="ot">-&gt;</span><span class=""> addBinding name v</span>
<span class="">      </span><span class="dt">Just</span><span class=""> t </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">case</span><span class=""> crumb </span><span class="kw">of</span>
<span class="">        </span><span class="dt">Nothing</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> t</span>
<span class="">        </span><span class="dt">Just</span><span class=""> cb </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">case</span><span class=""> cb </span><span class="kw">of</span>
<span class="">          </span><span class="dt">CPlus</span><span class=""> _ </span><span class="op">|</span><span class=""> t </span><span class="op">==</span><span class=""> </span><span class="dt">TInt</span><span class="">  </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="dt">TInt</span>
<span class="">          </span><span class="dt">COr</span><span class="">   _ </span><span class="op">|</span><span class=""> t </span><span class="op">==</span><span class=""> </span><span class="dt">TBool</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="dt">TBool</span>
<span class="">          </span><span class="dt">CAbs</span><span class=""> _ </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> t</span>
<span class="">          </span><span class="dt">CApp1</span><span class=""> _ </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">case</span><span class=""> t </span><span class="kw">of</span>
<span class="">            </span><span class="dt">TLam</span><span class=""> _ _ </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> t</span>
<span class="">          </span><span class="dt">CApp2</span><span class=""> e </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">do</span>
<span class="">            t&#39; </span><span class="ot">&lt;-</span><span class=""> check e</span>
<span class="">            </span><span class="kw">case</span><span class=""> t&#39; </span><span class="kw">of</span>
<span class="">              </span><span class="dt">TLam</span><span class=""> typ _ </span><span class="op">|</span><span class=""> typ </span><span class="op">==</span><span class=""> t </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> t</span>
</code></pre></div><p>That’s a bit of a mouthful, but can be broken up into sections. First off, if we hit this block of code, we’ve hit a variable in a program and need to unify its type. We first get the crumb and scope that has been accumulating throughout traversal of the AST. We then check if the variable in question is in scope; if not, we throw a <code>TypeError</code>. We next get the type environment <code>env</code>. If the variable in question is not bound in the type environment, we bind it to the appropriate type and return it using <code>addBinding</code>. If we came from a lambda abstraction, the (sub)expression must be <code>\x.x</code>, so we return the type of <code>x</code> in the environment, if it already exists. If we came from the second value of an application (i.e. the value being <em>applied</em> to a function), we check the type of the function it is being applied to – if it isn’t a lambda abstraction, the typechecker fails.</p><p>It’s worth noting that this last <code>CApp2</code> rule is exactly <em>why</em> the expression I noted earlier – <code>((\x.x) (\y.y)) 10</code> – fails. The subexpression <code>((\x.x) (\y.y))</code> doesn’t typecheck to a <code>TLam</code>; it fails to typecheck because <code>\y.y</code> isn’t unifiable. But I digress – the typechecker works reasonably well and I think the schema is simple enough to be interesting, even if not exactly practical/suitable for real-world usage in its current state.</p><p>If there exists a binding in the type environment for the variable in question, we just make sure that type matches what we expect and return it.</p><p>The rest of the <code>check</code> function consists of functions in the same vein as this one (the <code>:+:</code> branch, again omitting error-handling noise):</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">withCrumb ::</span><span class=""> </span><span class="dt">Typechecker</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">MoleculeCrumb</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Typechecker</span><span class=""> a</span>
<span class="">withCrumb action crumb </span><span class="ot">=</span><span class=""> local (_1 </span><span class="op">.~</span><span class=""> </span><span class="dt">Just</span><span class=""> crumb) action</span>

<span class="">check (e1 </span><span class="op">:+:</span><span class=""> e2) </span><span class="ot">=</span><span class=""> </span><span class="kw">do</span>
<span class="">  e1&#39; </span><span class="ot">&lt;-</span><span class=""> check e1 </span><span class="ot">`withCrumb`</span><span class=""> </span><span class="dt">CPlus</span><span class=""> e2</span>
<span class="">  e2&#39; </span><span class="ot">&lt;-</span><span class=""> check e2 </span><span class="ot">`withCrumb`</span><span class=""> </span><span class="dt">CPlus</span><span class=""> e1</span>
<span class="">  </span><span class="kw">case</span><span class=""> (e1&#39;, e2&#39;) </span><span class="kw">of</span>
<span class="">    (</span><span class="dt">TInt</span><span class="">, </span><span class="dt">TInt</span><span class="">) </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="dt">TInt</span>
</code></pre></div><p>where we set the <code>Crumb</code> in the expression with a helper function <code>withCrumb</code> (which makes use of the <code>local</code> and a common <code>lens</code>/operation) and propagate typechecking through the rest of the AST.</p><p>We can run the typechecker using the final function <code>typecheck</code> (which looks complex but just runs a typechecking operation with initially empty environments and no crumb):</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">typecheck ::</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Either</span><span class=""> </span><span class="dt">MoleculeError</span><span class=""> </span><span class="dt">MoleculeType</span>
<span class="">typecheck </span><span class="ot">=</span><span class=""> runTypecheck </span><span class="dt">Nothing</span><span class=""> S.empty M.empty</span>
<span class="">  </span><span class="kw">where</span><span class=""> runTypecheck crumb scope te expr </span><span class="ot">=</span><span class=""> </span>
<span class="">    runIdentity </span><span class="op">$</span><span class=""> evalStateT (runReaderT (runExceptT (check expr)) (crumb, scope)) te</span>
</code></pre></div><p>Now we have a static typechecker for Molecule expressions, which means, most importantly, that we can run expressions safely <em>without the types</em>, which in turn removes a lot of ambiguity from the actual evaluator and allows for faster evaluation since expressions need not be typechecked at runtime.</p><h3 id="evaluating-molecule-expressions">Evaluating Molecule Expressions</h3><p>Let’s get right to it – the code for evaluation in Molecule looks like this:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">type</span><span class=""> </span><span class="dt">Evaluator</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">ExceptT</span><span class=""> </span><span class="dt">MoleculeError</span><span class=""> (</span><span class="dt">Reader</span><span class=""> (</span><span class="dt">M.Map</span><span class=""> </span><span class="dt">Name</span><span class=""> </span><span class="dt">MoleculeValue</span><span class="">))</span>

<span class="ot">eval ::</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Evaluator</span><span class=""> </span><span class="dt">MoleculeValue</span>
<span class="">eval e </span><span class="ot">=</span><span class=""> </span><span class="kw">do</span>
<span class="">  env </span><span class="ot">&lt;-</span><span class=""> ask</span>
<span class="">  </span><span class="kw">case</span><span class=""> e </span><span class="kw">of</span>
<span class="">    </span><span class="dt">ETrue</span><span class="">   </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="op">$</span><span class=""> </span><span class="dt">VBool</span><span class=""> </span><span class="dt">True</span>
<span class="">    </span><span class="dt">EFalse</span><span class="">  </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="op">$</span><span class=""> </span><span class="dt">VBool</span><span class=""> </span><span class="dt">False</span>
<span class="">    </span><span class="dt">EInt</span><span class=""> x  </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="op">$</span><span class=""> </span><span class="dt">VInt</span><span class=""> x</span>
<span class="">    </span><span class="dt">EAbs</span><span class=""> name e1 </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="op">$</span><span class=""> </span><span class="dt">VLam</span><span class=""> env name e1</span>
<span class="">    </span><span class="dt">EVar</span><span class=""> nm </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="op">$</span><span class=""> fromJust (M.lookup nm env) </span>
<span class="">    e1 </span><span class="op">:+:</span><span class=""> e2 </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">do</span>
<span class="">      [a, b] </span><span class="ot">&lt;-</span><span class=""> </span><span class="fu">mapM</span><span class=""> eval [e1, e2]</span>
<span class="">      </span><span class="kw">case</span><span class=""> (a, b) </span><span class="kw">of</span>
<span class="">        (</span><span class="dt">VInt</span><span class=""> a&#39;, </span><span class="dt">VInt</span><span class=""> b&#39;) </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="op">.</span><span class=""> </span><span class="dt">VInt</span><span class=""> </span><span class="op">$</span><span class=""> a&#39; </span><span class="op">+</span><span class=""> b&#39;</span>
<span class="">    </span><span class="dt">EApp</span><span class=""> e1 e2 </span><span class="ot">-&gt;</span><span class=""> </span><span class="kw">do</span>
<span class="">      [e1&#39;, e2&#39;] </span><span class="ot">=</span><span class=""> </span><span class="fu">mapM</span><span class=""> eval [e1, e2]</span>
<span class="">      </span><span class="kw">case</span><span class=""> e1&#39; </span><span class="kw">of</span>
<span class="">        </span><span class="dt">VLam</span><span class=""> env&#39; name body </span><span class="ot">-&gt;</span><span class=""> local (</span><span class="fu">const</span><span class=""> </span><span class="op">$</span><span class=""> M.insert name e2&#39; env&#39;) </span><span class="op">$</span><span class=""> eval body</span>
</code></pre></div><p>I’ve removed the <code>:|:</code> rule for brevity (hint: it looks just like <code>:+:</code>). Most of this is pretty straightforward because we don’t have to deal with typechecking at runtime. The most complex evaluation rule is the one for <code>EApp</code>, which applies <code>e2</code> to <code>e1</code>. This rule says to evaluate <code>e1</code> and <code>e2</code>, then take the resulting lambda abstraction, bind the argument name to <code>e2</code>’s evaluated expression, then evaluate the lambda abstraction’s body with the modified environment.</p><p>Again, we can run the evaluator with a simple wrapper function <code>evaluate</code>:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">evaluate ::</span><span class=""> </span><span class="dt">MoleculeExpr</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Either</span><span class=""> </span><span class="dt">MoleculeError</span><span class=""> </span><span class="dt">MoleculeValue</span>
<span class="">evaluate </span><span class="ot">=</span><span class=""> runEval M.empty</span>
<span class="">  </span><span class="kw">where</span><span class=""> runEval env e </span><span class="ot">=</span><span class=""> runReader (runExceptT (eval e)) env</span>
</code></pre></div><p>…and that’s basically all there is to Molecule! The <code>mi</code> REPL is built with <a href="https://hackage.haskell.org/package/haskeline">haskeline</a> and supports type checking via <code>:t</code> (a la <code>ghci</code>) and evaluation by simply typing (no pun intended) expressions.</p><p>I’ve still got a long way to go in the programming languages world, but I’m proud of Molecule even if its type inference is a little flawed. My next project will either have a type system closer to <a href="http://en.wikipedia.org/wiki/Hindley–Milner_type_system">Hindley Milner</a> (so I can type infer with something closer to <a href="http://en.wikipedia.org/wiki/Hindley–Milner_type_system#Algorithm_W">Algorithm W</a>), or just make type annotations explicit (for a different set of challenges).</p><p>Again, Molecule’s full source code is <a href="https://github.com/5outh/Molecule">available on GitHub</a>.</p><p>Ben</p></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2014-07-21">2014-07-21</time></div></div></article><nav class="ui bottom attached segment deemphasized backlinks-container"><a class="ui right ribbon label zettel-tag " href="search.html?tag=Programming Languages" title="See all zettels tagged &#39;Programming Languages&#39;">Programming Languages</a><p></p></nav></div></div><div class="ui one column grid footer-version"><div class="center aligned column"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron" /></a></div></div></div></div></body></html>