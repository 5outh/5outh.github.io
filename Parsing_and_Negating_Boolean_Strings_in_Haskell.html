<!DOCTYPE html></!DOCTYPE html><html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><title>Parsing and Negating Boolean Strings in Haskell - Ben Kovach</title><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><style type="text/css">body{background-color:#eeeeee !important;font-family:"Ubuntu", serif !important}body .ui.container{font-family:"Ubuntu", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Kanit", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body div#neuron-theme-default-teal .zettel-content h1{background-color:rgba(0,181,173,0.1)}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a{color:#00b5ad}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#00b5ad}body div#neuron-theme-default-teal .deemphasized:hover div.item a:hover{color:#00b5ad !important}body div#neuron-theme-default-teal div#footnotes{border-top-color:#00b5ad}body div#neuron-theme-default-brown .zettel-content h1{background-color:rgba(165,103,63,0.1)}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a{color:#a5673f}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a5673f}body div#neuron-theme-default-brown .deemphasized:hover div.item a:hover{color:#a5673f !important}body div#neuron-theme-default-brown div#footnotes{border-top-color:#a5673f}body div#neuron-theme-default-red .zettel-content h1{background-color:rgba(219,40,40,0.1)}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a{color:#db2828}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#db2828}body div#neuron-theme-default-red .deemphasized:hover div.item a:hover{color:#db2828 !important}body div#neuron-theme-default-red div#footnotes{border-top-color:#db2828}body div#neuron-theme-default-orange .zettel-content h1{background-color:rgba(242,113,28,0.1)}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a{color:#f2711c}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#f2711c}body div#neuron-theme-default-orange .deemphasized:hover div.item a:hover{color:#f2711c !important}body div#neuron-theme-default-orange div#footnotes{border-top-color:#f2711c}body div#neuron-theme-default-yellow .zettel-content h1{background-color:rgba(251,189,8,0.1)}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a{color:#fbbd08}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#fbbd08}body div#neuron-theme-default-yellow .deemphasized:hover div.item a:hover{color:#fbbd08 !important}body div#neuron-theme-default-yellow div#footnotes{border-top-color:#fbbd08}body div#neuron-theme-default-olive .zettel-content h1{background-color:rgba(181,204,24,0.1)}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a{color:#b5cc18}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#b5cc18}body div#neuron-theme-default-olive .deemphasized:hover div.item a:hover{color:#b5cc18 !important}body div#neuron-theme-default-olive div#footnotes{border-top-color:#b5cc18}body div#neuron-theme-default-green .zettel-content h1{background-color:rgba(33,186,69,0.1)}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a{color:#21ba45}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#21ba45}body div#neuron-theme-default-green .deemphasized:hover div.item a:hover{color:#21ba45 !important}body div#neuron-theme-default-green div#footnotes{border-top-color:#21ba45}body div#neuron-theme-default-blue .zettel-content h1{background-color:rgba(33,133,208,0.1)}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a{color:#2185d0}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#2185d0}body div#neuron-theme-default-blue .deemphasized:hover div.item a:hover{color:#2185d0 !important}body div#neuron-theme-default-blue div#footnotes{border-top-color:#2185d0}body div#neuron-theme-default-violet .zettel-content h1{background-color:rgba(100,53,201,0.1)}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a{color:#6435c9}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#6435c9}body div#neuron-theme-default-violet .deemphasized:hover div.item a:hover{color:#6435c9 !important}body div#neuron-theme-default-violet div#footnotes{border-top-color:#6435c9}body div#neuron-theme-default-purple .zettel-content h1{background-color:rgba(163,51,200,0.1)}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a{color:#a333c8}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a333c8}body div#neuron-theme-default-purple .deemphasized:hover div.item a:hover{color:#a333c8 !important}body div#neuron-theme-default-purple div#footnotes{border-top-color:#a333c8}body div#neuron-theme-default-pink .zettel-content h1{background-color:rgba(224,57,151,0.1)}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a{color:#e03997}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#e03997}body div#neuron-theme-default-pink .deemphasized:hover div.item a:hover{color:#e03997 !important}body div#neuron-theme-default-pink div#footnotes{border-top-color:#e03997}body div#neuron-theme-default-grey .zettel-content h1{background-color:rgba(118,118,118,0.1)}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a{color:#767676}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#767676}body div#neuron-theme-default-grey .deemphasized:hover div.item a:hover{color:#767676 !important}body div#neuron-theme-default-grey div#footnotes{border-top-color:#767676}body div#neuron-theme-default-black .zettel-content h1{background-color:rgba(27,28,29,0.1)}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a{color:#1b1c1d}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#1b1c1d}body div#neuron-theme-default-black .deemphasized:hover div.item a:hover{color:#1b1c1d !important}body div#neuron-theme-default-black div#footnotes{border-top-color:#1b1c1d}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.84999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f8f8f8}body div.zettel-view .zettel-content pre{padding:0.5em 0.5em 0.5em 0.5em;overflow:auto;max-width:100%}body div.zettel-view .zettel-content div.pandoc-code{margin-left:auto;margin-right:auto}body div.zettel-view .zettel-content div.pandoc-code pre{background-color:#f8f8f8}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.backlinks-container{background-color:#eeeeee !important}body ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body ul.context-list > li{list-style-type:lower-roman}body span.zettel-link-container span.zettel-link a{font-weight:bold;text-decoration:none}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}body nav.top-menu{padding-top:1em;padding-bottom:1em;justify-content:center;text-align:center}body nav.top-menu > *{padding-left:0px;padding-right:0px}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}</style><link href="https://fonts.googleapis.com/css?family=Kanit|Ubuntu|Roboto+Mono&amp;display=swap" rel="stylesheet" /><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta content="Ben Kovach" name="author" /><meta content="It appears that the dailyprogrammer subreddit is back after a pretty
long hiatus, and they kicked back into gear with a really interesting
problem. The problem was, paraphrasing:
" name="description" /><link href="https://kovach.me/Parsing_and_Negating_Boolean_Strings_in_Haskell.html" rel="canonical" /><meta content="Parsing and Negating Boolean Strings in Haskell" property="og:title" /><meta content="Ben Kovach" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[]</script><style type="text/css">pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style></head><body><div class="ui fluid container" id="neuron-theme-default-blue"><nav class="top-menu"><div class="ui inverted compact neuron icon menu blue"><a class="left item" href="." title="Home"><i class="home icon"></i></a><a class="left item" href="search.html" title="Search Zettels"><i class="search icon"></i></a><a class="center item" href="https://github.com/5outh/zettelkasten/edit/master/Parsing and Negating Boolean Strings in Haskell.md" title="Edit this Zettel"><i class="edit icon"></i></a><a class="right item" href="z-index.html" title="All Zettels (z-index)"><i class="tree icon"></i></a></div></nav><div class="ui text container" id="zettel-container" style="position: relative"><div id="zettel-container-anchor" style="position: absolute; top: -24px; left: 0"></div><div class="zettel-view"><article class="ui raised attached segment zettel-content"><h1>Parsing and Negating Boolean Strings in Haskell</h1><div class="pandoc"><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span>
<span class=""> </span>
<span class="kw">import</span><span class=""> </span><span class="dt">Text.ParserCombinators.Parsec</span>
<span class="kw">import</span><span class=""> </span><span class="dt">Text.ParserCombinators.Parsec.Token</span><span class=""> </span><span class="kw">hiding</span><span class=""> (parens)</span>
<span class="kw">import</span><span class=""> </span><span class="dt">Text.ParserCombinators.Parsec.Expr</span>
<span class="kw">import</span><span class=""> </span><span class="dt">Control.Applicative</span><span class=""> </span><span class="kw">hiding</span><span class=""> ((&lt;|&gt;))</span>
<span class="kw">import</span><span class=""> </span><span class="dt">Control.Monad</span>
<span class="kw">import</span><span class=""> </span><span class="dt">Prelude</span><span class=""> </span><span class="kw">hiding</span><span class=""> (not)</span>
</code></pre></div><p>It appears that <a href="http://www.reddit.com/r/dailyprogrammer/">the dailyprogrammer subreddit</a> is back after a pretty long hiatus, and they kicked back into gear with a really interesting problem. The problem was, paraphrasing:</p><blockquote><p>Given a Boolean expression as a string S, compute and print the negation of S as a string using DeMorgan’s laws.</p></blockquote><p><a href="http://www.reddit.com/r/dailyprogrammer/comments/1qira9/111213_challenge_135_intermediate_de_morgans_law/">The problem is also detailed in full here</a>. I completed the challenge and posted my solution to reddit, but wanted to share it here as well, so here it is, with slight modifications:</p><p>This is a problem that is heavily suited to three major things that Haskell advocates: Algebraic Data Types, Pattern Matching, and Monadic Parsing. First off, if you’ve had any experience with automata theory, it’s pretty clear that the input language of Boolean expressions can be represented by a <a href="http://en.wikipedia.org/wiki/Context-free_grammar">context free grammar</a>. It just so happens that Haskell makes it incredibly easy to model CFGs right out of the box using Algebraic Data Types.</p><p>Let’s take a look at this data type representing Boolean expressions:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">data</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">Not</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span>
<span class="">          </span><span class="op">|</span><span class=""> </span><span class="dt">And</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span>
<span class="">          </span><span class="op">|</span><span class=""> </span><span class="dt">Or</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span>
<span class="">          </span><span class="op">|</span><span class=""> </span><span class="dt">Var</span><span class=""> </span><span class="dt">Char</span><span class=""> </span>
<span class="">          </span><span class="op">|</span><span class=""> </span><span class="dt">SubExpr</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span>
<span class="">          </span><span class="kw">deriving</span><span class=""> </span><span class="dt">Eq</span>
<span class="">          </span><span class="ot">```</span>

<span class="ot">Simple. Now, the main problem of this challenge was actually performing</span>
<span class="ot">the simplification of the not operation. Using pattern matching, we can</span>
<span class="ot">*directly encode these rules* in the following manner:</span>

<span class="ot">```</span><span class="">haskell</span>
<span class="fu">not</span><span class="ot"> ::</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Expr</span>
<span class="fu">not</span><span class=""> (</span><span class="dt">Not</span><span class=""> e)     </span><span class="ot">=</span><span class=""> e</span>
<span class="fu">not</span><span class=""> (</span><span class="dt">And</span><span class=""> e1 e2) </span><span class="ot">=</span><span class=""> </span><span class="dt">Or</span><span class=""> (</span><span class="fu">not</span><span class=""> e1) (</span><span class="fu">not</span><span class=""> e2)</span>
<span class="fu">not</span><span class=""> (</span><span class="dt">Or</span><span class=""> e1 e2)  </span><span class="ot">=</span><span class=""> </span><span class="dt">And</span><span class=""> (</span><span class="fu">not</span><span class=""> e1) (</span><span class="fu">not</span><span class=""> e2)</span>
<span class="fu">not</span><span class=""> (</span><span class="dt">Var</span><span class=""> c)     </span><span class="ot">=</span><span class=""> </span><span class="dt">Not</span><span class=""> (</span><span class="dt">Var</span><span class=""> c)</span>
<span class="fu">not</span><span class=""> (</span><span class="dt">SubExpr</span><span class=""> e) </span><span class="ot">=</span><span class=""> </span><span class="fu">not</span><span class=""> e</span>
</code></pre></div><p>Here we’re giving a literal definition of rules for negating Boolean expressions. If you use Haskell, this is really easy to read. If you don’t: stare at it for a second; you’ll see what it’s doing! That’s the brunt of the challenge, right there. That’s it. Encode a Boolean expression into an <code>Expr</code> and call <code>not</code> on it, and it will spit out a new <code>Expr </code>expressing the negation of your original expression. DeMorgan’s laws are represented in the <code>And</code> and <code>Or</code> rules.We can also do this in a slightly modified way, using a function <code>simplify :: Expr -&gt; Expr</code> that simplifies expressions and another function <code>not = simplify . Not</code> to compute the same thing. It’s a similar solution so I won’t post it, but if you’d like to, feel free to experiment and/or add more simplification rules (e.g. <code>simplify e@(And a b) = if a == b then a else e</code>). We can also display our expressions as a string by declaring <code>Expr</code> an instance of <code>Show</code> in the following way:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">instance</span><span class=""> </span><span class="dt">Show</span><span class=""> </span><span class="dt">Expr</span><span class=""> </span><span class="kw">where</span>
<span class="">  </span><span class="fu">show</span><span class=""> (</span><span class="dt">Not</span><span class=""> e)     </span><span class="ot">=</span><span class=""> </span><span class="st">&quot;NOT &quot;</span><span class=""> </span><span class="op">++</span><span class=""> </span><span class="fu">show</span><span class=""> e</span>
<span class="">  </span><span class="fu">show</span><span class=""> (</span><span class="dt">And</span><span class=""> e1 e2) </span><span class="ot">=</span><span class=""> </span><span class="fu">show</span><span class=""> e1 </span><span class="op">++</span><span class=""> </span><span class="st">&quot; AND &quot;</span><span class=""> </span><span class="op">++</span><span class=""> </span><span class="fu">show</span><span class=""> e2</span>
<span class="">  </span><span class="fu">show</span><span class=""> (</span><span class="dt">Or</span><span class=""> e1 e2)  </span><span class="ot">=</span><span class=""> </span><span class="fu">show</span><span class=""> e1 </span><span class="op">++</span><span class=""> </span><span class="st">&quot; OR &quot;</span><span class="">  </span><span class="op">++</span><span class=""> </span><span class="fu">show</span><span class=""> e2</span>
<span class="">  </span><span class="fu">show</span><span class=""> (</span><span class="dt">Var</span><span class=""> c)     </span><span class="ot">=</span><span class=""> [c]</span>
<span class="">  </span><span class="fu">show</span><span class=""> (</span><span class="dt">SubExpr</span><span class=""> e) </span><span class="ot">=</span><span class=""> </span><span class="st">&quot;(&quot;</span><span class=""> </span><span class="op">++</span><span class=""> </span><span class="fu">show</span><span class=""> e </span><span class="op">++</span><span class=""> </span><span class="st">&quot;)&quot;</span>
</code></pre></div><p>Now we can type in Boolean expressions using our data type, not them, and print them out as nice expressions. But, now we are faced with, in my opinion, the tougher part of the challenge. We’re able to actually compute everything we need to, but what about parsing a Boolean expression (as a string) into an <code>Expr</code>? We can use a monadic parsing library, namely Haskell’s beloved <a href="http://www.haskell.org/haskellwiki/Parsec">Parsec</a>, to do this in a rather simple way. We’ll be using Parsec’s <a href="http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Token.html">Token</a> and <a href="http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Expr.html">Expr</a> libraries, as well as the base, in this example. Let’s take a look.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">parseExpr ::</span><span class=""> </span><span class="dt">String</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Either</span><span class=""> </span><span class="dt">ParseError</span><span class=""> </span><span class="dt">Expr</span>
<span class="">parseExpr </span><span class="ot">=</span><span class=""> parse expr </span><span class="st">&quot;&quot;</span>
<span class="">  </span><span class="kw">where</span><span class=""> expr      </span><span class="ot">=</span><span class=""> buildExpressionParser operators term </span><span class="op">&lt;?&gt;</span><span class=""> </span><span class="st">&quot;compound expression&quot;</span>
<span class="">        term      </span><span class="ot">=</span><span class="">  parens expr </span><span class="op">&lt;|&gt;</span><span class=""> variable </span><span class="op">&lt;?&gt;</span><span class=""> </span><span class="st">&quot;full expression&quot;</span>
<span class="">        operators </span><span class="ot">=</span><span class=""> [ [</span><span class="dt">Prefix</span><span class=""> (string </span><span class="st">&quot;NOT&quot;</span><span class=""> </span><span class="op">&gt;&gt;</span><span class=""> spaces </span><span class="op">&gt;&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="dt">Not</span><span class="">)]</span>
<span class="">                    , [binary </span><span class="st">&quot;AND&quot;</span><span class=""> </span><span class="dt">And</span><span class="">]</span>
<span class="">                    , [binary </span><span class="st">&quot;OR&quot;</span><span class=""> </span><span class="dt">Or</span><span class="">] ]</span>
<span class="">          </span><span class="kw">where</span><span class=""> binary n c </span><span class="ot">=</span><span class=""> </span><span class="dt">Infix</span><span class=""> (string n </span><span class="op">*&gt;</span><span class=""> spaces </span><span class="op">*&gt;</span><span class=""> </span><span class="fu">pure</span><span class=""> c) </span><span class="dt">AssocLeft</span>
<span class="">        variable </span><span class="ot">=</span><span class=""> </span><span class="dt">Var</span><span class="">     </span><span class="op">&lt;$&gt;</span><span class=""> (letter </span><span class="op">&lt;*</span><span class=""> spaces)                              </span>
<span class="">                           </span><span class="op">&lt;?&gt;</span><span class=""> </span><span class="st">&quot;variable&quot;</span>
<span class="">        parens p </span><span class="ot">=</span><span class=""> </span><span class="dt">SubExpr</span><span class=""> </span><span class="op">&lt;$&gt;</span><span class=""> (char </span><span class="ch">&#39;(&#39;</span><span class=""> </span><span class="op">*&gt;</span><span class=""> spaces </span><span class="op">*&gt;</span><span class=""> p </span><span class="op">&lt;*</span><span class=""> char </span><span class="ch">&#39;)&#39;</span><span class=""> </span><span class="op">&lt;*</span><span class=""> spaces) </span>
<span class="">                           </span><span class="op">&lt;?&gt;</span><span class=""> </span><span class="st">&quot;parens&quot;</span>
</code></pre></div><p>We essentially define the structure of our input here and parse it into an Expr using a bunch of case-specific parsing rules. <code>variable</code> parses a single <code>char</code> into a <code>Var</code>, <code>parens</code> matches and returns a <code>SubExpr</code>, and everything else is handled by using the convenience function <code>buildExpressionParser</code> along with a list of operator strings, the types they translate to and their operator precedence. Here we’re using applicative style to do our parsing, but monadic style is fine too. <a href="http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/">Check this out for more on applicative style parsing</a>.</p><p>Given that, we can define a <code>main</code> function to read in a file of expressions and output the negation of each of the expressions, like so:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="">main </span><span class="ot">=</span><span class=""> </span><span class="fu">mapM_</span><span class=""> printNotExpr </span><span class="op">.</span><span class=""> </span><span class="fu">lines</span><span class=""> </span><span class="op">=&lt;&lt;</span><span class=""> </span><span class="fu">readFile</span><span class=""> </span><span class="st">&quot;inputs.txt&quot;</span>
<span class="">  </span><span class="kw">where</span><span class=""> printNotExpr e </span><span class="ot">=</span><span class=""> </span><span class="kw">case</span><span class=""> parseExpr e </span><span class="kw">of</span>
<span class="">                          </span><span class="dt">Right</span><span class=""> x </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">print</span><span class=""> </span><span class="op">$</span><span class=""> </span><span class="fu">not</span><span class=""> x</span>
<span class="">                          </span><span class="dt">Left</span><span class="">  e </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">error</span><span class=""> </span><span class="op">$</span><span class=""> </span><span class="fu">show</span><span class=""> e</span>
</code></pre></div><p>Concise and to the point. We make sure that each line gets parsed properly, not the expressions, and print them. Here’s what we get when we run the program:</p><div class="pandoc-code nosyntax"><pre><code>inputs.txt                             --- output

a                                      --- NOT a
NOT a                                  --- a
a AND b                                --- NOT a OR NOT b 
NOT a AND b                            --- a OR NOT b
NOT (a AND b)                          --- a AND b
NOT (a OR b AND c) OR NOT(a AND NOT b) --- (a OR b AND c) AND (a AND NOT b)</code></pre></div><p><a href="https://gist.github.com/5outh/7452588#file-demorgan-hs">Finally, here’s the full source on Github</a>.</p><p>Thanks for reading!</p></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2013-11-13">2013-11-13</time></div></div></article><nav class="ui bottom attached segment deemphasized backlinks-container"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" data-inverted="" data-position="right center" data-tooltip="Tags: home"><a href=".">Ben Kovach</a></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc">Linking by tag: <code>Essays</code></div></li></ul></li></ul><a class="ui right ribbon label zettel-tag " href="search.html?tag=Haskell" title="See all zettels tagged &#39;Haskell&#39;">Haskell</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Essays" title="See all zettels tagged &#39;Essays&#39;">Essays</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Programming Languages" title="See all zettels tagged &#39;Programming Languages&#39;">Programming Languages</a><p></p></nav></div></div><div class="ui one column grid footer-version"><div class="center aligned column"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron" /></a></div></div></div></div></body></html>