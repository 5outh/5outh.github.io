<!DOCTYPE html></!DOCTYPE html><html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><title>Graphs and Topological Sorting in the Functional Paradigm - Ben Kovach</title><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><style type="text/css">body{background-color:#eeeeee !important;font-family:"Ubuntu", serif !important}body .ui.container{font-family:"Ubuntu", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Kanit", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body div#neuron-theme-default-teal .zettel-content h1{background-color:rgba(0,181,173,0.1)}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a{color:#00b5ad}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#00b5ad}body div#neuron-theme-default-teal .deemphasized:hover div.item a:hover{color:#00b5ad !important}body div#neuron-theme-default-teal div#footnotes{border-top-color:#00b5ad}body div#neuron-theme-default-brown .zettel-content h1{background-color:rgba(165,103,63,0.1)}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a{color:#a5673f}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a5673f}body div#neuron-theme-default-brown .deemphasized:hover div.item a:hover{color:#a5673f !important}body div#neuron-theme-default-brown div#footnotes{border-top-color:#a5673f}body div#neuron-theme-default-red .zettel-content h1{background-color:rgba(219,40,40,0.1)}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a{color:#db2828}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#db2828}body div#neuron-theme-default-red .deemphasized:hover div.item a:hover{color:#db2828 !important}body div#neuron-theme-default-red div#footnotes{border-top-color:#db2828}body div#neuron-theme-default-orange .zettel-content h1{background-color:rgba(242,113,28,0.1)}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a{color:#f2711c}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#f2711c}body div#neuron-theme-default-orange .deemphasized:hover div.item a:hover{color:#f2711c !important}body div#neuron-theme-default-orange div#footnotes{border-top-color:#f2711c}body div#neuron-theme-default-yellow .zettel-content h1{background-color:rgba(251,189,8,0.1)}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a{color:#fbbd08}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#fbbd08}body div#neuron-theme-default-yellow .deemphasized:hover div.item a:hover{color:#fbbd08 !important}body div#neuron-theme-default-yellow div#footnotes{border-top-color:#fbbd08}body div#neuron-theme-default-olive .zettel-content h1{background-color:rgba(181,204,24,0.1)}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a{color:#b5cc18}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#b5cc18}body div#neuron-theme-default-olive .deemphasized:hover div.item a:hover{color:#b5cc18 !important}body div#neuron-theme-default-olive div#footnotes{border-top-color:#b5cc18}body div#neuron-theme-default-green .zettel-content h1{background-color:rgba(33,186,69,0.1)}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a{color:#21ba45}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#21ba45}body div#neuron-theme-default-green .deemphasized:hover div.item a:hover{color:#21ba45 !important}body div#neuron-theme-default-green div#footnotes{border-top-color:#21ba45}body div#neuron-theme-default-blue .zettel-content h1{background-color:rgba(33,133,208,0.1)}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a{color:#2185d0}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#2185d0}body div#neuron-theme-default-blue .deemphasized:hover div.item a:hover{color:#2185d0 !important}body div#neuron-theme-default-blue div#footnotes{border-top-color:#2185d0}body div#neuron-theme-default-violet .zettel-content h1{background-color:rgba(100,53,201,0.1)}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a{color:#6435c9}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#6435c9}body div#neuron-theme-default-violet .deemphasized:hover div.item a:hover{color:#6435c9 !important}body div#neuron-theme-default-violet div#footnotes{border-top-color:#6435c9}body div#neuron-theme-default-purple .zettel-content h1{background-color:rgba(163,51,200,0.1)}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a{color:#a333c8}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a333c8}body div#neuron-theme-default-purple .deemphasized:hover div.item a:hover{color:#a333c8 !important}body div#neuron-theme-default-purple div#footnotes{border-top-color:#a333c8}body div#neuron-theme-default-pink .zettel-content h1{background-color:rgba(224,57,151,0.1)}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a{color:#e03997}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#e03997}body div#neuron-theme-default-pink .deemphasized:hover div.item a:hover{color:#e03997 !important}body div#neuron-theme-default-pink div#footnotes{border-top-color:#e03997}body div#neuron-theme-default-grey .zettel-content h1{background-color:rgba(118,118,118,0.1)}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a{color:#767676}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#767676}body div#neuron-theme-default-grey .deemphasized:hover div.item a:hover{color:#767676 !important}body div#neuron-theme-default-grey div#footnotes{border-top-color:#767676}body div#neuron-theme-default-black .zettel-content h1{background-color:rgba(27,28,29,0.1)}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a{color:#1b1c1d}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#1b1c1d}body div#neuron-theme-default-black .deemphasized:hover div.item a:hover{color:#1b1c1d !important}body div#neuron-theme-default-black div#footnotes{border-top-color:#1b1c1d}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.84999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f8f8f8}body div.zettel-view .zettel-content pre{padding:0.5em 0.5em 0.5em 0.5em;overflow:auto;max-width:100%}body div.zettel-view .zettel-content div.pandoc-code{margin-left:auto;margin-right:auto}body div.zettel-view .zettel-content div.pandoc-code pre{background-color:#f8f8f8}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.backlinks-container{background-color:#eeeeee !important}body ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body ul.context-list > li{list-style-type:lower-roman}body span.zettel-link-container span.zettel-link a{font-weight:bold;text-decoration:none}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}body nav.top-menu{padding-top:1em;padding-bottom:1em;justify-content:center;text-align:center}body nav.top-menu > *{padding-left:0px;padding-right:0px}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}</style><link href="https://fonts.googleapis.com/css?family=Kanit|Ubuntu|Roboto+Mono&amp;display=swap" rel="stylesheet" /><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta content="Ben Kovach" name="author" /><meta content="From Wikipedia:
" name="description" /><link href="https://kovach.me/Graphs_and_Topological_Sorting_in_the_Functional_Paradigm.html" rel="canonical" /><meta content="Graphs and Topological Sorting in the Functional Paradigm" property="og:title" /><meta content="Ben Kovach" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[]</script><style type="text/css">pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style></head><body><div class="ui fluid container" id="neuron-theme-default-blue"><nav class="top-menu"><div class="ui inverted compact neuron icon menu blue"><a class="left item" href="." title="Home"><i class="home icon"></i></a><a class="left item" href="search.html" title="Search Zettels"><i class="search icon"></i></a><a class="center item" href="https://github.com/5outh/zettelkasten/edit/master/Graphs and Topological Sorting in the Functional Paradigm.md" title="Edit this Zettel"><i class="edit icon"></i></a><a class="right item" href="z-index.html" title="All Zettels (z-index)"><i class="tree icon"></i></a></div></nav><div class="ui text container" id="zettel-container" style="position: relative"><div id="zettel-container-anchor" style="position: absolute; top: -24px; left: 0"></div><div class="zettel-view"><article class="ui raised attached segment zettel-content"><h1>Graphs and Topological Sorting in the Functional Paradigm</h1><div class="pandoc"><h3 id="what-is-a-graph">What is a Graph?</h3><p>From <em><a href="http://en.wikipedia.org/wiki/Graph_(mathematics)">Wikipedia</a></em>:</p><blockquote><p>In <a href="http://en.wikipedia.org/wiki/Mathematics" title="Mathematics">mathematics</a>, a <strong>graph</strong> is a representation of a set of objects where some pairs of the objects are connected by links. The interconnected objects are represented by mathematical abstractions called <a href="http://en.wikipedia.org/wiki/Vertex_(graph_theory)" title="Vertex (graph theory)">vertices</a>, and the links that connect some pairs of vertices are called edges.</p></blockquote><p>Simply put, a graph is just a bunch of points with links between them. A road map is a simple example: roads being edges, and intersections being vertices. In fact, <a href="http://maps.google.com/">Google maps</a> uses graphs for just this purpose! Graphs are widely used in a wide variety of places. <a href="http://www.facebook.com/">Facebook</a> uses graphs to model your friend connections and likes. In fact, the entire internet is just a giant graph; websites act as vertices, with hyperlinks as edges. Graphs are highly useful structures, as they can be used to model many different types of situations, and as such, they will be the focus of this blog post. I am going to discuss one way to represent a graph in the Haskell programming language, and how to functionally solve a common problem using graphs. Graphs are often represented visually like this:</p><center><img src="http://2.bp.blogspot.com/-WS-YS-sS1Yw/UL_BNs1BumI/AAAAAAAAAEY/ZwGmaHAtcBI/s400/ABCDEF.png"><p class="small"><em>Graph representing abstract data</em></p></img></center>
<p>This graph links the first six letters of the alphabet in an arbitrary way. This data doesn’t really mean anything, but it will serve as a simple foray into the world of graphs, and provides an initial graph to work towards representing in Haskell. Let’s get right to it; here’s the data structure we’ll be using, along with some convenience methods:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">module</span><span class=""> </span><span class="dt">Graph</span><span class="">(</span>
<span class="">  </span><span class="dt">Graph</span><span class="">(</span><span class="dt">Graph</span><span class="">),</span>
<span class="">  removeEdge,</span>
<span class="">  outbound,</span>
<span class="">  inbound</span>
<span class="">)</span><span class="kw">where</span>

<span class="kw">data</span><span class=""> </span><span class="dt">Graph</span><span class=""> a </span><span class="ot">=</span><span class=""> </span><span class="dt">Graph</span><span class="">{</span><span class="ot"> vertices ::</span><span class=""> [a],</span><span class="ot"> edges ::</span><span class=""> [(a, a)] } </span><span class="kw">deriving</span><span class=""> </span><span class="dt">Show</span>

<span class="ot">removeEdge ::</span><span class=""> (</span><span class="dt">Eq</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> (a, a) </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Graph</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Graph</span><span class=""> a</span>
<span class="">removeEdge x (</span><span class="dt">Graph</span><span class=""> v e) </span><span class="ot">=</span><span class=""> </span><span class="dt">Graph</span><span class=""> v (</span><span class="fu">filter</span><span class=""> (</span><span class="op">/=</span><span class="">x) e)</span>

<span class="ot">connections ::</span><span class=""> (</span><span class="dt">Eq</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> ((a, a) </span><span class="ot">-&gt;</span><span class=""> a) </span><span class="ot">-&gt;</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Graph</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> [(a, a)]</span>
<span class="">connections f x (</span><span class="dt">Graph</span><span class=""> _ e) </span><span class="ot">=</span><span class=""> </span><span class="fu">filter</span><span class=""> ((</span><span class="op">==</span><span class="">x) </span><span class="op">.</span><span class=""> f) e</span>

<span class="co">--outbound connections</span>
<span class="">outbound a </span><span class="ot">=</span><span class=""> connections </span><span class="fu">fst</span><span class=""> a</span>

<span class="co">--inbound connections</span>
<span class="">inbound a </span><span class="ot">=</span><span class=""> connections </span><span class="fu">snd</span><span class=""> a</span>
</code></pre></div><p>First we define the actual <code>Graph a</code> data type: It’s simply a set of vertices and edges in the form of 2-tuples (The tuple <code>(a, b)</code> connects vertex <code>a</code> to vertex <code>b</code>), which fits our definition. I’ve also defined the <code>removeEdge</code> method, which does just what you’d expect. The <code>outbound</code> and <code>inbound</code> functions find the outbound and inbound connections to any point in the graph, respectively. They make use of the polymorphic connections method in order to get this done in a small amount of code. Finally, the <code>Graph</code> module exports the relevant functions at the top of the file. Now that we’ve got our framework in order, we can go ahead and build the graph we mentioned above:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">import</span><span class=""> </span><span class="dt">Data.List</span><span class=""> </span><span class="co">--for later</span>
<span class="kw">import</span><span class=""> </span><span class="dt">System.Environment</span><span class=""> </span><span class="co">--for later</span>
<span class="kw">import</span><span class=""> </span><span class="dt">Graph</span>

<span class="kw">data</span><span class=""> </span><span class="dt">Letter</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">A</span><span class=""> </span><span class="op">|</span><span class=""> </span><span class="dt">B</span><span class=""> </span><span class="op">|</span><span class=""> </span><span class="dt">C</span><span class=""> </span><span class="op">|</span><span class=""> </span><span class="dt">D</span><span class=""> </span><span class="op">|</span><span class=""> </span><span class="dt">E</span><span class=""> </span><span class="op">|</span><span class=""> </span><span class="dt">F</span><span class=""> </span><span class="kw">deriving</span><span class=""> (</span><span class="dt">Show</span><span class="">, </span><span class="dt">Eq</span><span class="">, </span><span class="dt">Enum</span><span class="">)</span>

<span class="ot">sample ::</span><span class=""> </span><span class="dt">Graph</span><span class=""> </span><span class="dt">Letter</span>
<span class="">sample </span><span class="ot">=</span><span class=""> </span><span class="dt">Graph</span><span class=""> [</span><span class="dt">A</span><span class="">,</span><span class="dt">B</span><span class="">,</span><span class="dt">C</span><span class="">,</span><span class="dt">D</span><span class="">,</span><span class="dt">E</span><span class="">,</span><span class="dt">F</span><span class="">] [(</span><span class="dt">A</span><span class="">, </span><span class="dt">B</span><span class="">), (</span><span class="dt">A</span><span class="">, </span><span class="dt">C</span><span class="">), (</span><span class="dt">B</span><span class="">, </span><span class="dt">D</span><span class="">), (</span><span class="dt">C</span><span class="">, </span><span class="dt">D</span><span class="">), (</span><span class="dt">D</span><span class="">, </span><span class="dt">E</span><span class="">), (</span><span class="dt">D</span><span class="">, </span><span class="dt">F</span><span class="">), (</span><span class="dt">B</span><span class="">, </span><span class="dt">C</span><span class="">), (</span><span class="dt">F</span><span class="">, </span><span class="dt">E</span><span class="">)]</span>
</code></pre></div><p>We import the <code>Graph</code> module and define a simple <code>Letter</code> data type, then build our <code>Graph</code> from it. The set of vertices are the letters A, B, C, D, E, and F, and the edges are modeled as above. Now that we know how to build graphs, we can start modeling more important information with them.</p><h4 id="modeling-actual-scenarios-using-graphs">Modeling Actual Scenarios using Graphs</h4><p>Suppose some of the characters from NBC’s *<a href="http://www.nbc.com/parks-and-recreation/">Parks and Recreation</a>*have just finished competing in a dance competition, and we know the following about their rankings:</p><ul><li>Leslie beat April.</li><li>April beat Ann.</li><li>Ron beat April.</li><li>Ron beat Ann.</li><li>April beat Andy.</li><li>Leslie beat Ron.</li><li>Andy beat Jerry.</li><li>Ron beat Andy.</li><li>Ann beat Jerry.</li><li>Leslie beat Andy.</li><li>Ann beat Andy.</li></ul><p>This is a little hard to mentally parse, so why don’t we model it as a graph to make it a little more readable? Each person can be represented as a vertex, with outgoing edges representing connections to the people they beat.</p><center><img src="http://4.bp.blogspot.com/-coJ1uHjEo94/UMC_E4j2EPI/AAAAAAAAAE0/fMKyRGqMfqU/s400/PandR.png"><p class="small"><em>A graph of dance competition results</em></p></center>
<p>It would be nice to be able to be able to read scenarios like this from a text file containing the important data and parse it into a graph. Let’s go ahead and set up a function to do this for us, so we don’t have to hard-code each and every graph that we want to use: Here’s our data file, with a list of space-separated connections, one on each line:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="dt">Leslie</span><span class=""> </span><span class="dt">Andy</span>
<span class="dt">April</span><span class=""> </span><span class="dt">Andy</span>
<span class="dt">Ron</span><span class=""> </span><span class="dt">Ann</span>
<span class="dt">Ron</span><span class=""> </span><span class="dt">April</span>
<span class="dt">Ann</span><span class=""> </span><span class="dt">Jerry</span>
<span class="dt">Ann</span><span class=""> </span><span class="dt">Andy</span>
<span class="dt">Leslie</span><span class=""> </span><span class="dt">April</span>
<span class="dt">Ron</span><span class=""> </span><span class="dt">Andy</span>
<span class="dt">Leslie</span><span class=""> </span><span class="dt">Ron</span>
<span class="dt">Andy</span><span class=""> </span><span class="dt">Jerry</span>
<span class="dt">April</span><span class=""> </span><span class="dt">Ann</span>
</code></pre></div><p>And our parsing function:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">graphFromFile ::</span><span class=""> </span><span class="dt">String</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">IO</span><span class=""> (</span><span class="dt">Graph</span><span class=""> </span><span class="dt">String</span><span class="">)</span>
<span class="">graphFromFile f </span><span class="ot">=</span><span class=""> </span><span class="kw">do</span>
<span class="">  contents </span><span class="ot">&lt;-</span><span class=""> </span><span class="fu">readFile</span><span class=""> f</span>
<span class="">  </span><span class="kw">let</span><span class=""> info   </span><span class="ot">=</span><span class=""> </span><span class="fu">map</span><span class=""> </span><span class="fu">words</span><span class=""> </span><span class="op">$</span><span class=""> </span><span class="fu">lines</span><span class=""> contents</span>
<span class="">      verts </span><span class="ot">=</span><span class=""> nub </span><span class="op">.</span><span class=""> </span><span class="fu">concat</span><span class=""> </span><span class="op">$</span><span class=""> info</span>
<span class="">      conns  </span><span class="ot">=</span><span class=""> </span><span class="fu">map</span><span class=""> (\[a, b] </span><span class="ot">-&gt;</span><span class=""> (a, b)) info</span>
<span class="">      graph  </span><span class="ot">=</span><span class=""> </span><span class="dt">Graph</span><span class=""> verts conns</span>
<span class="">  </span><span class="fu">return</span><span class=""> graph</span>
</code></pre></div><p>The <code>graphFromFile</code> function takes a <code>String</code> and returns an <code>IO (Graph String)</code>. The function reads a file, parses it into two important pieces: <code>verts</code> (the set of all unique strings in the file, or, our vertices) and <code>conns</code> (the set of connections between strings in the file). It then builds a <code>Graph</code> from this data, wraps it in the <code>IO</code> monad with <code>return</code>, and gives it back. Now you might have been wondering from the beginning of this section what the ranking from the dance competition was (maybe you even figured it out on your own!). How do we do this programmatically, using our graph?</p><h4 id="enter-topological-sort">Enter Topological Sort</h4><p>Again, from <em><a href="http://en.wikipedia.org/wiki/Topological_sort">Wikipedia</a>:</em></p><blockquote><p>In <a href="http://en.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, a <strong>topological sort</strong> of a <a href="http://en.wikipedia.org/wiki/Directed_graph" title="Directed graph">directed graph</a> <em>is a linear ordering of its</em><a href="http://en.wikipedia.org/wiki/Vertex_(graph_theory)" title="Vertex (graph theory)">vertices</a> <em>such that, for every edge</em>uv, u comes before v in the ordering.</p></blockquote><p>In our case, this just means that each person must come before <em>all</em>of the people that he or she beat in the competition, in the ordering. The basic procedure for topological sort is as follows:</p><ul><li><code>L</code> = {} –sorted list</li><li><code>S</code> = Set of vertices with no incoming connections</li><li>while <code>S</code> is not empty:<ul><li>for each vertex <code>v</code> in <code>S</code> with no incoming connections:<ul><li>push <code>v</code> to <code>L</code></li><li>for each edge <code>e</code> from <code>v</code> to <code>u</code>:<ul><li>remove <code>e</code> from graph</li><li>if <code>u</code> has no more incoming connections, push <code>u</code> to <code>S</code></li></ul></li></ul></li></ul></li><li>if edges still exist in the graph, error: there is at least one cycle in the graph</li><li>Otherwise, return <code>L</code></li></ul><p>If you do not understand this, I urge you to work through topologically sorting a graph on paper first; it’s not too tough to understand once you’ve done it on paper, but can get a little confusing in psuedocode. The problem with this algorithm is that you see a ton of loops – control structures that we do not have in Haskell. Therefore, we must rely on recursion, folds, and maps to achieve what we want to do. Here’s how it looks:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">tsort ::</span><span class=""> (</span><span class="dt">Eq</span><span class=""> a) </span><span class="ot">=&gt;</span><span class=""> </span><span class="dt">Graph</span><span class=""> a </span><span class="ot">-&gt;</span><span class=""> [a]</span>
<span class="">tsort graph  </span><span class="ot">=</span><span class=""> tsort&#39; [] (noInbound graph) graph</span>
<span class="">  </span><span class="kw">where</span><span class=""> noInbound (</span><span class="dt">Graph</span><span class=""> v e) </span><span class="ot">=</span><span class=""> </span><span class="fu">filter</span><span class=""> (</span><span class="fu">flip</span><span class=""> </span><span class="fu">notElem</span><span class=""> </span><span class="op">$</span><span class=""> </span><span class="fu">map</span><span class=""> </span><span class="fu">snd</span><span class=""> e) v</span>
<span class="">        tsort&#39; l []    (</span><span class="dt">Graph</span><span class=""> _ []) </span><span class="ot">=</span><span class=""> </span><span class="fu">reverse</span><span class=""> l</span>
<span class="">        tsort&#39; l []    _            </span><span class="ot">=</span><span class=""> </span><span class="fu">error</span><span class=""> </span><span class="st">&quot;There is at least one cycle in this graph.&quot;</span>
<span class="">        tsort&#39; l (n</span><span class="op">:</span><span class="">s) g            </span><span class="ot">=</span><span class=""> tsort&#39; (n</span><span class="op">:</span><span class="">l) s&#39; g&#39;</span>
<span class="">          </span><span class="kw">where</span><span class=""> outEdges </span><span class="ot">=</span><span class=""> outbound n g</span>
<span class="">                outNodes </span><span class="ot">=</span><span class=""> </span><span class="fu">map</span><span class=""> </span><span class="fu">snd</span><span class=""> outEdges</span>
<span class="">                g&#39;       </span><span class="ot">=</span><span class=""> </span><span class="fu">foldr</span><span class=""> removeEdge g outEdges</span>
<span class="">                s&#39;       </span><span class="ot">=</span><span class=""> s </span><span class="op">++</span><span class=""> </span><span class="fu">filter</span><span class=""> (</span><span class="fu">null</span><span class=""> </span><span class="op">.</span><span class=""> </span><span class="fu">flip</span><span class=""> inbound g&#39;) outNodes</span>
</code></pre></div><p>Our <code>tsort</code> function first finds the elements in the graph with no incoming edges using the function noInbound. We pass this into a sub-routine <code>tsort&#39;</code> that takes a sorted list <code>l</code>, a list of vertices with no incoming connections <code>(n:s)</code>, and a graph <code>g</code>. We operate on the first element of the set of vertices with no incoming connections <code>n</code>, finding <code>outEdges</code> (the outgoing edges from <code>n</code>), and <code>outNodes</code> (the nodes that <code>n</code> points to). We build a new graph <code>g&#39;</code> with the <code>outEdges</code> removed, and find the nodes in <code>g&#39;</code> with no inbound connections, and add them to <code>s</code>. We then recursively call <code>tsort&#39;</code> with these new parameters (and prepend our current <code>n</code> to the sorted list), until there are no more nodes to check. At this point, if the edge list in the graph is empty, all is well and we return the list of sorted elements. Otherwise, an error is thrown stating that there is at least one cycle in the graph. Now that we’ve got that, we’re ready to find out how everyone ranked in the dance competition!</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="op">&gt;</span><span class=""> </span><span class="kw">let</span><span class=""> danceOutcome </span><span class="ot">=</span><span class=""> graphFromFile </span><span class="st">&quot;people.txt&quot;</span><span class=""> </span><span class="op">&gt;&gt;=</span><span class=""> \f </span><span class="ot">-&gt;</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="op">$</span><span class=""> tsort f</span>
<span class="op">&gt;</span><span class=""> [</span><span class="st">&quot;Leslie&quot;</span><span class="">, </span><span class="st">&quot;Ron&quot;</span><span class="">, </span><span class="st">&quot;April&quot;</span><span class="">, </span><span class="st">&quot;Ann&quot;</span><span class="">, </span><span class="st">&quot;Andy&quot;</span><span class="">, </span><span class="st">&quot;Jerry&quot;</span><span class="">]</span>
</code></pre></div><p>(Of course Jerry lost!)</p><h4 id="conclusion">Conclusion</h4><p>As you can see, Graphs are very useful data structures. They can be used to model a huge variety of things (see how many more you can come up with, they’re everywhere!). Topological sort in particular is a pretty remarkable algorithm, and can be applied in many different situations from the one above. For example, finding paths through college courses with prerequisites. It’s even used in UNIX systems to schedule processes according to their dependencies.</p><p>Hope you enjoyed the post!</p><p>Until next time,</p><p>Ben</p></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2012-06-12">2012-06-12</time></div></div></article><nav class="ui bottom attached segment deemphasized backlinks-container"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" data-inverted="" data-position="right center" data-tooltip="Tags: home"><a href=".">Ben Kovach</a></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc">Linking by tag: <code>Essays</code></div></li></ul></li></ul><a class="ui right ribbon label zettel-tag " href="search.html?tag=Haskell" title="See all zettels tagged &#39;Haskell&#39;">Haskell</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Essays" title="See all zettels tagged &#39;Essays&#39;">Essays</a><p></p></nav></div></div><div class="ui one column grid footer-version"><div class="center aligned column"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron" /></a></div></div></div></div></body></html>