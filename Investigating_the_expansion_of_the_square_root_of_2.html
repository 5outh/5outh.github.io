<!DOCTYPE html></!DOCTYPE html><html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><title>Implementing a fractional data type and investigating the expansion of the square root of 2 - Ben Kovach</title><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><style type="text/css">body{background-color:#eeeeee !important;font-family:"Ubuntu", serif !important}body .ui.container{font-family:"Ubuntu", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Kanit", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body div#neuron-theme-default-teal .zettel-content h1{background-color:rgba(0,181,173,0.1)}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a{color:#00b5ad}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#00b5ad}body div#neuron-theme-default-teal .deemphasized:hover div.item a:hover{color:#00b5ad !important}body div#neuron-theme-default-teal div#footnotes{border-top-color:#00b5ad}body div#neuron-theme-default-brown .zettel-content h1{background-color:rgba(165,103,63,0.1)}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a{color:#a5673f}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a5673f}body div#neuron-theme-default-brown .deemphasized:hover div.item a:hover{color:#a5673f !important}body div#neuron-theme-default-brown div#footnotes{border-top-color:#a5673f}body div#neuron-theme-default-red .zettel-content h1{background-color:rgba(219,40,40,0.1)}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a{color:#db2828}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#db2828}body div#neuron-theme-default-red .deemphasized:hover div.item a:hover{color:#db2828 !important}body div#neuron-theme-default-red div#footnotes{border-top-color:#db2828}body div#neuron-theme-default-orange .zettel-content h1{background-color:rgba(242,113,28,0.1)}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a{color:#f2711c}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#f2711c}body div#neuron-theme-default-orange .deemphasized:hover div.item a:hover{color:#f2711c !important}body div#neuron-theme-default-orange div#footnotes{border-top-color:#f2711c}body div#neuron-theme-default-yellow .zettel-content h1{background-color:rgba(251,189,8,0.1)}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a{color:#fbbd08}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#fbbd08}body div#neuron-theme-default-yellow .deemphasized:hover div.item a:hover{color:#fbbd08 !important}body div#neuron-theme-default-yellow div#footnotes{border-top-color:#fbbd08}body div#neuron-theme-default-olive .zettel-content h1{background-color:rgba(181,204,24,0.1)}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a{color:#b5cc18}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#b5cc18}body div#neuron-theme-default-olive .deemphasized:hover div.item a:hover{color:#b5cc18 !important}body div#neuron-theme-default-olive div#footnotes{border-top-color:#b5cc18}body div#neuron-theme-default-green .zettel-content h1{background-color:rgba(33,186,69,0.1)}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a{color:#21ba45}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#21ba45}body div#neuron-theme-default-green .deemphasized:hover div.item a:hover{color:#21ba45 !important}body div#neuron-theme-default-green div#footnotes{border-top-color:#21ba45}body div#neuron-theme-default-blue .zettel-content h1{background-color:rgba(33,133,208,0.1)}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a{color:#2185d0}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#2185d0}body div#neuron-theme-default-blue .deemphasized:hover div.item a:hover{color:#2185d0 !important}body div#neuron-theme-default-blue div#footnotes{border-top-color:#2185d0}body div#neuron-theme-default-violet .zettel-content h1{background-color:rgba(100,53,201,0.1)}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a{color:#6435c9}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#6435c9}body div#neuron-theme-default-violet .deemphasized:hover div.item a:hover{color:#6435c9 !important}body div#neuron-theme-default-violet div#footnotes{border-top-color:#6435c9}body div#neuron-theme-default-purple .zettel-content h1{background-color:rgba(163,51,200,0.1)}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a{color:#a333c8}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a333c8}body div#neuron-theme-default-purple .deemphasized:hover div.item a:hover{color:#a333c8 !important}body div#neuron-theme-default-purple div#footnotes{border-top-color:#a333c8}body div#neuron-theme-default-pink .zettel-content h1{background-color:rgba(224,57,151,0.1)}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a{color:#e03997}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#e03997}body div#neuron-theme-default-pink .deemphasized:hover div.item a:hover{color:#e03997 !important}body div#neuron-theme-default-pink div#footnotes{border-top-color:#e03997}body div#neuron-theme-default-grey .zettel-content h1{background-color:rgba(118,118,118,0.1)}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a{color:#767676}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#767676}body div#neuron-theme-default-grey .deemphasized:hover div.item a:hover{color:#767676 !important}body div#neuron-theme-default-grey div#footnotes{border-top-color:#767676}body div#neuron-theme-default-black .zettel-content h1{background-color:rgba(27,28,29,0.1)}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a{color:#1b1c1d}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#1b1c1d}body div#neuron-theme-default-black .deemphasized:hover div.item a:hover{color:#1b1c1d !important}body div#neuron-theme-default-black div#footnotes{border-top-color:#1b1c1d}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.84999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f8f8f8}body div.zettel-view .zettel-content pre{padding:0.5em 0.5em 0.5em 0.5em;overflow:auto;max-width:100%}body div.zettel-view .zettel-content div.pandoc-code{margin-left:auto;margin-right:auto}body div.zettel-view .zettel-content div.pandoc-code pre{background-color:#f8f8f8}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.backlinks-container{background-color:#eeeeee !important}body ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body ul.context-list > li{list-style-type:lower-roman}body span.zettel-link-container span.zettel-link a{font-weight:bold;text-decoration:none}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}body nav.top-menu{padding-top:1em;padding-bottom:1em;justify-content:center;text-align:center}body nav.top-menu > *{padding-left:0px;padding-right:0px}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}</style><link href="https://fonts.googleapis.com/css?family=Kanit|Ubuntu|Roboto+Mono&amp;display=swap" rel="stylesheet" /><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta content="Ben Kovach" name="author" /><meta content="A couple of weeks ago, I completed Project Euler #57: Investigating the
Expansion of the Square Root of 2. I found the problem really
interesting, since it required me to write up my own fractional
operations (addition, division, etc.)
" name="description" /><link href="https://kovach.me/Investigating_the_expansion_of_the_square_root_of_2.html" rel="canonical" /><meta content="Implementing a fractional data type and investigating the expansion of the square root of 2" property="og:title" /><meta content="Ben Kovach" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[]</script><style type="text/css">pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style></head><body><div class="ui fluid container" id="neuron-theme-default-blue"><nav class="top-menu"><div class="ui inverted compact neuron icon menu blue"><a class="left item" href="." title="Home"><i class="home icon"></i></a><a class="left item" href="search.html" title="Search Zettels"><i class="search icon"></i></a><a class="center item" href="https://github.com/5outh/zettelkasten/edit/master/Investigating the expansion of the square root of 2.md" title="Edit this Zettel"><i class="edit icon"></i></a><a class="right item" href="z-index.html" title="All Zettels (z-index)"><i class="tree icon"></i></a></div></nav><div class="ui text container" id="zettel-container" style="position: relative"><div id="zettel-container-anchor" style="position: absolute; top: -24px; left: 0"></div><div class="zettel-view"><article class="ui raised attached segment zettel-content"><h1>Implementing a fractional data type and investigating the expansion of the square root of 2</h1><div class="pandoc"><p>A couple of weeks ago, I completed <a href="http://projecteuler.net/problem=57">Project Euler #57: Investigating the Expansion of the Square Root of 2</a>. I found the problem really interesting, since it required me to write up my own fractional operations (addition, division, etc.)</p><p>Today, I decided that I wanted to take my minimally defined fractional library and make it a more full-featured one. First, I’ll first walk through the building of the data type and implementing fractional operations, and then I’ll get to my solution of the Project Euler problem.</p><p>First thing’s first. A <code>Fraction</code> is defined as a numerator and a denominator. My fractions consist of only Integers, and here’s how the data type is defined:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">data</span><span class=""> </span><span class="dt">Fraction</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">Frac</span><span class=""> </span><span class="dt">Integer</span><span class=""> </span><span class="dt">Integer</span><span class=""> </span><span class="co">-- Numerator Denominator</span>

<span class="kw">instance</span><span class=""> </span><span class="dt">Show</span><span class=""> </span><span class="dt">Fraction</span><span class=""> </span><span class="kw">where</span>
<span class="">  </span><span class="fu">show</span><span class=""> (</span><span class="dt">Frac</span><span class=""> a b) </span><span class="ot">=</span><span class=""> (</span><span class="fu">show</span><span class=""> a) </span><span class="op">++</span><span class=""> </span><span class="st">&quot; / &quot;</span><span class=""> </span><span class="op">++</span><span class=""> (</span><span class="fu">show</span><span class=""> b)</span>
</code></pre></div><p>I wanted fractions to show up in the form <code>x / y</code>, so that is what the instance of <code>Show</code> I defined does. So, now that we have a data type, what can we do with it?</p><p>Here’s a list of common functions that I think are necessary in the definition of a fraction: Addition, Subtraction, Multiplication, Division, Exponentiation, Simplification, Negation, getting the Numerator, and getting the Denominator. Let’s start with the simple ones:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">num ::</span><span class=""> </span><span class="dt">Fraction</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Integer</span>
<span class="">num (</span><span class="dt">Frac</span><span class=""> a _) </span><span class="ot">=</span><span class=""> a</span>

<span class="ot">denom ::</span><span class=""> </span><span class="dt">Fraction</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Integer</span>
<span class="">denom (</span><span class="dt">Frac</span><span class=""> _ b) </span><span class="ot">=</span><span class=""> b</span>
</code></pre></div><p>Those are are <code>numerator</code> and <code>denominator</code> functions. We simply take the first or second argument of the <code>Frac</code> in order to get the parameter that we need, and disregard the other one (using <code>_</code>) since it’s unused. Simplifying is also simple enough. We just need to divide the numerator and the denominator by the greatest common divisor of the two. Since Haskell gives us a <code>GCD</code> function, this is pretty darn simple.</p><p>Here’s how it’s implemented:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="ot">simplify ::</span><span class=""> </span><span class="dt">Fraction</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Fraction</span>
<span class="">simplify (</span><span class="dt">Frac</span><span class=""> a b) </span><span class="ot">=</span><span class=""> </span><span class="dt">Frac</span><span class=""> (a </span><span class="ot">`quot`</span><span class=""> factor) (b </span><span class="ot">`quot`</span><span class=""> factor)</span>
<span class="">	</span><span class="kw">where</span><span class=""> factor </span><span class="ot">=</span><span class=""> </span><span class="fu">gcd</span><span class=""> a b</span>
</code></pre></div><p>Easy! We just make a new fraction out of the divided values. The function<code>quot</code> is basically just integer division that truncates the result towards 0. The second half of that is unimportant in this instance, since we’re dividing by the <code>GCD</code> of the numbers and the result will always be an integer value. Okay, so we have a couple of functions. Great! But, what about implementing addition, subtraction, etc?</p><p>Well, basically what we want to do here is define a couple of instances of numeric types for our Fractional data type. The first instance we need to derive is <code>Num</code>, which has a few operations that we want:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">instance</span><span class=""> </span><span class="dt">Num</span><span class=""> </span><span class="dt">Fraction</span><span class=""> </span><span class="kw">where</span>
<span class="">  (</span><span class="op">-</span><span class="">) f (</span><span class="dt">Frac</span><span class=""> a b)          </span><span class="ot">=</span><span class=""> f </span><span class="op">+</span><span class=""> (</span><span class="dt">Frac</span><span class=""> (</span><span class="op">-</span><span class="">a) b)</span>
<span class="">  (</span><span class="op">+</span><span class="">) (</span><span class="dt">Frac</span><span class=""> a b) (</span><span class="dt">Frac</span><span class=""> c d) </span><span class="ot">=</span><span class=""> </span><span class="dt">Frac</span><span class=""> num denom</span>
<span class="">    </span><span class="kw">where</span><span class=""> denom </span><span class="ot">=</span><span class=""> </span><span class="fu">lcm</span><span class=""> b d</span>
<span class="">          num   </span><span class="ot">=</span><span class=""> a </span><span class="op">*</span><span class=""> (denom </span><span class="ot">`quot`</span><span class=""> b) </span><span class="op">+</span><span class=""> c </span><span class="op">*</span><span class=""> (denom </span><span class="ot">`quot`</span><span class=""> d)</span>
<span class="">  (</span><span class="op">*</span><span class="">) (</span><span class="dt">Frac</span><span class=""> a b) (</span><span class="dt">Frac</span><span class=""> c d) </span><span class="ot">=</span><span class=""> </span><span class="dt">Frac</span><span class=""> (a</span><span class="op">*</span><span class="">c) (b</span><span class="op">*</span><span class="">d)</span>
<span class="">  </span><span class="fu">negate</span><span class=""> (</span><span class="dt">Frac</span><span class=""> a b)         </span><span class="ot">=</span><span class=""> </span><span class="dt">Frac</span><span class=""> (</span><span class="op">-</span><span class="">a) b</span>
<span class="">  </span><span class="fu">abs</span><span class=""> f                     </span><span class="ot">=</span><span class=""> fmapF </span><span class="fu">abs</span><span class=""> f</span>
<span class="">    </span><span class="kw">where</span><span class=""> fmapF f (</span><span class="dt">Frac</span><span class=""> a b) </span><span class="ot">=</span><span class=""> </span><span class="dt">Frac</span><span class=""> (f a) (f b)</span>
<span class="">  </span><span class="fu">fromInteger</span><span class=""> x             </span><span class="ot">=</span><span class=""> </span><span class="dt">Frac</span><span class=""> x </span><span class="dv">1</span>
<span class="">  </span><span class="fu">signum</span><span class=""> (</span><span class="dt">Frac</span><span class=""> a b)         </span><span class="ot">=</span><span class=""> </span><span class="kw">if</span><span class=""> a </span><span class="op">==</span><span class=""> </span><span class="dv">0</span><span class=""> </span><span class="kw">then</span><span class=""> </span><span class="dv">0</span>
<span class="">                              </span><span class="kw">else</span><span class="">  </span><span class="kw">if</span><span class=""> b </span><span class="op">&gt;</span><span class=""> </span><span class="dv">0</span><span class=""> </span><span class="kw">then</span>
<span class="">                                    </span><span class="kw">if</span><span class=""> a </span><span class="op">&lt;</span><span class=""> </span><span class="dv">0</span><span class=""> </span><span class="kw">then</span><span class=""> (</span><span class="op">-</span><span class="dv">1</span><span class="">)</span>
<span class="">                                    </span><span class="kw">else</span><span class=""> </span><span class="dv">1</span>
<span class="">                              </span><span class="kw">else</span><span class="">  </span><span class="kw">if</span><span class=""> a </span><span class="op">&lt;</span><span class=""> </span><span class="dv">0</span><span class=""> </span><span class="kw">then</span><span class=""> </span><span class="dv">1</span>
<span class="">                                    </span><span class="kw">else</span><span class=""> (</span><span class="op">-</span><span class="dv">1</span><span class="">)</span>
</code></pre></div><p>The three “common” operators (<code>+</code>,<code>-</code>,<code>*</code>) are defined here, which means that we can now evaluate expressions such as <code>Frac 1 2 * Frac 1 2</code>. Cool, right? Those three operations are fairly self-explanatory, and the code (hopefully) isn’t too tough to follow. There are also three other function definitions here, that maybe aren’t quite as clear. The function <code>negate</code> simply turns a negative fraction positive, or a positive fraction negative. The function <code>abs</code> takes the absolute value of the fraction. This is fairly simple; we just use a function that maps <code>abs</code> (Integer absolute value) over the numerator and denominator of the fraction. The last is <code>signum</code>, which looks probably the most complicated, but all it actually does is tells us whether the <code>Fraction</code>is less than, greater than, or equal to 0 (returning -1, 1, and 0, respectively). Cool, so since we got all of those functions out of <code>Num</code>, where can we find the rest? We’re missing <code>/</code>, so we’ll make our <code>Fraction</code> an instance of <code>Fractional</code>. Seems appropriate, right?</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">instance</span><span class=""> </span><span class="dt">Fractional</span><span class=""> </span><span class="dt">Fraction</span><span class=""> </span><span class="kw">where</span>
<span class="">  (</span><span class="op">/</span><span class="">) f             </span><span class="ot">=</span><span class=""> (</span><span class="op">*</span><span class="">) f </span><span class="op">.</span><span class=""> </span><span class="fu">recip</span>
<span class="">  </span><span class="fu">recip</span><span class=""> (</span><span class="dt">Frac</span><span class=""> a b)  </span><span class="ot">=</span><span class=""> </span><span class="dt">Frac</span><span class=""> b a</span>
<span class="">  </span><span class="fu">fromRational</span><span class=""> r    </span><span class="ot">=</span><span class=""> </span><span class="dt">Frac</span><span class=""> (</span><span class="fu">numerator</span><span class=""> r) (</span><span class="fu">denominator</span><span class=""> r)</span>
</code></pre></div><p>Cool, we get division out of that, which is simple enough! We just take the reciprocal of the second fraction, and multiply the two. This may look a little funky, so I’ll explain that last. The other two functions defined here are <code>recip</code> and <code>fromRational</code>. <code>recip</code> simply flips the numerator and denominator in a <code>Fraction</code>, and this is easily handled with pattern matching. <code>fromRational</code> takes a rational number (which is provided the <code>numerator</code> and <code>denominator</code> functions) and turns it into a <code>Fraction</code>. Knowing what the <code>numerator</code> and <code>denominator</code> functions are, this function is incredibly trivial.</p><p>Okay, so about that division function. Our division appears to take only one argument, but it actually takes two. <code>(*) f f&#39;</code> is just syntactic sugar for <code>f * f&#39;</code>. We want to compose the function <code>f</code> with the function <code>recip f&#39;</code>, so we use the function <code>(*)</code>, apply it to <code>f</code>, and then apply that to the function <code>recip</code>, which is then called on the second argument of the function.</p><p>Alright! We’ve got plenty of functions at our disposal now, so what’s next? Well, we want to be able to compare <code>Fractions</code>, so let’s go ahead and make it an instance of <code>Eq</code> and <code>Ord</code>, which allow us to check equivalency and order, respectively.</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">instance</span><span class=""> </span><span class="dt">Eq</span><span class=""> </span><span class="dt">Fraction</span><span class=""> </span><span class="kw">where</span>
<span class="">  (</span><span class="op">/=</span><span class="">) f    </span><span class="ot">=</span><span class=""> </span><span class="fu">not</span><span class=""> </span><span class="op">.</span><span class=""> (</span><span class="op">==</span><span class="">) f</span>
<span class="">  (</span><span class="op">==</span><span class="">) f f&#39; </span><span class="ot">=</span><span class=""> (x </span><span class="op">==</span><span class=""> x&#39;) </span><span class="op">&amp;&amp;</span><span class=""> (y </span><span class="op">==</span><span class=""> y&#39;)</span>
<span class="">      </span><span class="kw">where</span><span class=""> (</span><span class="dt">Frac</span><span class=""> x y) </span><span class="ot">=</span><span class=""> simplify f</span>
<span class="">            (</span><span class="dt">Frac</span><span class=""> x&#39; y&#39;) </span><span class="ot">=</span><span class=""> simplify f&#39;</span>
<span class="">  </span>
<span class="kw">instance</span><span class=""> </span><span class="dt">Ord</span><span class=""> </span><span class="dt">Fraction</span><span class=""> </span><span class="kw">where</span>
<span class="">  </span><span class="fu">compare</span><span class=""> (</span><span class="dt">Frac</span><span class=""> a b) (</span><span class="dt">Frac</span><span class=""> c d) </span><span class="ot">=</span><span class=""> </span><span class="fu">compare</span><span class=""> (a </span><span class="ot">`quot`</span><span class=""> b) (c </span><span class="ot">`quot`</span><span class=""> d)</span>
<span class="">  (</span><span class="op">&lt;</span><span class="">)  f    </span><span class="ot">=</span><span class=""> (</span><span class="op">==</span><span class="">) </span><span class="dt">LT</span><span class=""> </span><span class="op">.</span><span class=""> </span><span class="fu">compare</span><span class=""> f</span>
<span class="">  (</span><span class="op">&gt;</span><span class="">)  f    </span><span class="ot">=</span><span class=""> (</span><span class="op">==</span><span class="">) </span><span class="dt">GT</span><span class=""> </span><span class="op">.</span><span class=""> </span><span class="fu">compare</span><span class=""> f</span>
<span class="">  (</span><span class="op">&gt;=</span><span class="">) f    </span><span class="ot">=</span><span class=""> </span><span class="fu">not</span><span class=""> </span><span class="op">.</span><span class=""> (</span><span class="op">&lt;</span><span class="">) f</span>
<span class="">  (</span><span class="op">&lt;=</span><span class="">) f    </span><span class="ot">=</span><span class=""> </span><span class="fu">not</span><span class=""> </span><span class="op">.</span><span class=""> (</span><span class="op">&gt;</span><span class="">) f</span>
<span class="">  </span><span class="fu">max</span><span class="">  f f&#39; </span><span class="ot">=</span><span class=""> </span><span class="kw">if</span><span class=""> f </span><span class="op">&lt;</span><span class=""> f&#39; </span><span class="kw">then</span><span class=""> f&#39; </span><span class="kw">else</span><span class=""> f</span>
<span class="">  </span><span class="fu">min</span><span class="">  f f&#39; </span><span class="ot">=</span><span class=""> </span><span class="kw">if</span><span class=""> f </span><span class="op">&lt;</span><span class=""> f&#39; </span><span class="kw">then</span><span class=""> f </span><span class="kw">else</span><span class=""> f&#39;</span>
</code></pre></div><p>There’s a lot of functions that are similar in structure to our <code>/</code> function from earlier, so understanding what is happening with those will make these much easier to understand. Starting with <code>Eq</code>, we have two functions, <code>/=</code> (not equals) and <code>==</code>. <code>==</code> simply checks to see if the simplified version of <code>f</code> and the simplified version of <code>f&#39;</code> have the same numerators and denominators. <code>/=</code> basically just returns the opposite of <code>==</code> by calling <code>not</code> on the result. <code>Ord</code> isn’t too tough either.</p><p>First we have <code>compare</code>, which returns a comparator (<code>LT</code>, <code>GT</code>, or <code>EQ</code>) based on the relationship between two <code>Fractions</code>. The inequality functions are all designed around this function. The <code>max</code> and <code>min</code> functions are simple, and designed around our inequality functions. So, what’s left? I decided I wanted to experiment, so I decided to also make <code>Fraction</code> an instance of <a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids">Monoid</a> and give `Fraction` a simpler constructor. Here’s the rest!</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">instance</span><span class=""> </span><span class="dt">Monoid</span><span class=""> </span><span class="dt">Fraction</span><span class=""> </span><span class="kw">where</span>
<span class="">  </span><span class="fu">mempty</span><span class="">  </span><span class="ot">=</span><span class=""> </span><span class="dv">0</span>
<span class="">  </span><span class="fu">mappend</span><span class=""> </span><span class="ot">=</span><span class=""> (</span><span class="op">+</span><span class="">)</span>
<span class="">  </span><span class="fu">mconcat</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="fu">foldr</span><span class=""> </span><span class="fu">mappend</span><span class=""> </span><span class="fu">mempty</span>

<span class="ot">(%) ::</span><span class=""> </span><span class="dt">Integer</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Integer</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">Fraction</span>
<span class="">(</span><span class="op">%</span><span class="">) a </span><span class="ot">=</span><span class=""> simplify </span><span class="op">.</span><span class=""> </span><span class="dt">Frac</span><span class=""> a</span>
</code></pre></div><p>The instance of <code>Monoid</code> defines a couple of functions: <code>mempty</code>, <code>mappend</code>, and <code>mconcat</code>. <code>mempty</code> is the minimal value for the <code>Monoid</code>.I chose 0 (which gets automatically boxed into a <code>Fraction</code>). <code>mappend</code> is a combiner function, and I thought that addition of fractions fit this bill well enough, so I simply gave it an alias. <code>mconcat</code> concatenates a list of fractions with some function, and in our case, sums the entire list. Our type constructor (<code>%</code>) takes two integers and boxes them up into a <code>Fraction</code>, which is then simplified. Easy enough. One final note on all of this. You may have noticed that exponentiation (<code>^</code>) isn’t implemented here. But, it actually is! Turns out, any data type that has a <code>Num</code> instance defined (like our <code>Fraction</code>) can use the <code>^</code> operator. So things like <code>(1 % 2)^2</code> actually get evaluated properly. (In this case, to <code>1 % 4</code>).</p><p>All right! Let’s use this small library to solve <a href="http://projecteuler.net/problem=57">Project Euler #57</a>! Knowing how to use the <code>Fraction</code> library, this should be relatively easy to follow. Here we go:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">import</span><span class=""> </span><span class="dt">Fraction</span>

<span class="">main </span><span class="ot">=</span><span class=""> </span><span class="fu">return</span><span class=""> </span><span class="op">.</span><span class=""> </span><span class="fu">length</span><span class=""> </span><span class="op">.</span><span class=""> </span><span class="fu">filter</span><span class=""> moreInNum </span><span class="op">.</span><span class=""> </span><span class="fu">map</span><span class=""> sqrtTwo </span><span class="op">$</span><span class=""> [</span><span class="dv">1</span><span class="op">..</span><span class="dv">1000</span><span class="">]</span>
<span class="">  </span><span class="kw">where</span><span class=""> moreInNum f </span><span class="ot">=</span><span class=""> </span><span class="fu">length</span><span class=""> ( (</span><span class="fu">show</span><span class=""> </span><span class="op">.</span><span class=""> num) f ) </span><span class="op">&gt;</span><span class=""> </span><span class="fu">length</span><span class=""> ( (</span><span class="fu">show</span><span class=""> </span><span class="op">.</span><span class=""> denom) f)</span>
<span class="">        sqrtTwo </span><span class="ot">=</span><span class=""> simplify </span><span class="op">.</span><span class=""> (</span><span class="op">+</span><span class="">) </span><span class="dv">1</span><span class=""> </span><span class="op">.</span><span class=""> sqrtTwo&#39;</span>
<span class="">          </span><span class="kw">where</span><span class=""> sqrtTwo&#39; </span><span class="dv">1</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dv">1</span><span class=""> </span><span class="op">%</span><span class=""> </span><span class="dv">2</span>
<span class="">                sqrtTwo&#39; n </span><span class="ot">=</span><span class=""> </span><span class="dv">1</span><span class=""> </span><span class="op">/</span><span class=""> ( </span><span class="dv">2</span><span class=""> </span><span class="op">+</span><span class=""> sqrtTwo&#39; (</span><span class="fu">pred</span><span class=""> n) )</span>
</code></pre></div><p>Fairly simple. We directly implement the function and run it on each iteration, building a list as we go. We then filter our list so that the only entries left are the ones that have more digits in the numerator than the denominator. Lastly, we evaluate the length of that list, which gives us the answer.</p><p><a href="http://lpaste.net/97144">View the full Fraction.hs source on lpaste.</a></p><p>Until next time!</p><p>Ben</p></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2012-08-15">2012-08-15</time></div></div></article><nav class="ui bottom attached segment deemphasized backlinks-container"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" data-inverted="" data-position="right center" data-tooltip="Tags: home"><a href=".">Ben Kovach</a></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc">Linking by tag: <code>Essays</code></div></li></ul></li></ul><a class="ui right ribbon label zettel-tag " href="search.html?tag=Math" title="See all zettels tagged &#39;Math&#39;">Math</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Haskell" title="See all zettels tagged &#39;Haskell&#39;">Haskell</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Essays" title="See all zettels tagged &#39;Essays&#39;">Essays</a><p></p></nav></div></div><div class="ui one column grid footer-version"><div class="center aligned column"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron" /></a></div></div></div></div></body></html>