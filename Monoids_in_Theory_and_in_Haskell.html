<!DOCTYPE html></!DOCTYPE html><html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><title>Monoids in Theory and in Haskell - Ben Kovach</title><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><style type="text/css">body{background-color:#eeeeee !important;font-family:"Ubuntu", serif !important}body .ui.container{font-family:"Ubuntu", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Kanit", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body div#neuron-theme-default-teal .zettel-content h1{background-color:rgba(0,181,173,0.1)}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a{color:#00b5ad}body div#neuron-theme-default-teal span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#00b5ad}body div#neuron-theme-default-teal .deemphasized:hover div.item a:hover{color:#00b5ad !important}body div#neuron-theme-default-teal div#footnotes{border-top-color:#00b5ad}body div#neuron-theme-default-brown .zettel-content h1{background-color:rgba(165,103,63,0.1)}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a{color:#a5673f}body div#neuron-theme-default-brown span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a5673f}body div#neuron-theme-default-brown .deemphasized:hover div.item a:hover{color:#a5673f !important}body div#neuron-theme-default-brown div#footnotes{border-top-color:#a5673f}body div#neuron-theme-default-red .zettel-content h1{background-color:rgba(219,40,40,0.1)}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a{color:#db2828}body div#neuron-theme-default-red span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#db2828}body div#neuron-theme-default-red .deemphasized:hover div.item a:hover{color:#db2828 !important}body div#neuron-theme-default-red div#footnotes{border-top-color:#db2828}body div#neuron-theme-default-orange .zettel-content h1{background-color:rgba(242,113,28,0.1)}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a{color:#f2711c}body div#neuron-theme-default-orange span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#f2711c}body div#neuron-theme-default-orange .deemphasized:hover div.item a:hover{color:#f2711c !important}body div#neuron-theme-default-orange div#footnotes{border-top-color:#f2711c}body div#neuron-theme-default-yellow .zettel-content h1{background-color:rgba(251,189,8,0.1)}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a{color:#fbbd08}body div#neuron-theme-default-yellow span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#fbbd08}body div#neuron-theme-default-yellow .deemphasized:hover div.item a:hover{color:#fbbd08 !important}body div#neuron-theme-default-yellow div#footnotes{border-top-color:#fbbd08}body div#neuron-theme-default-olive .zettel-content h1{background-color:rgba(181,204,24,0.1)}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a{color:#b5cc18}body div#neuron-theme-default-olive span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#b5cc18}body div#neuron-theme-default-olive .deemphasized:hover div.item a:hover{color:#b5cc18 !important}body div#neuron-theme-default-olive div#footnotes{border-top-color:#b5cc18}body div#neuron-theme-default-green .zettel-content h1{background-color:rgba(33,186,69,0.1)}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a{color:#21ba45}body div#neuron-theme-default-green span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#21ba45}body div#neuron-theme-default-green .deemphasized:hover div.item a:hover{color:#21ba45 !important}body div#neuron-theme-default-green div#footnotes{border-top-color:#21ba45}body div#neuron-theme-default-blue .zettel-content h1{background-color:rgba(33,133,208,0.1)}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a{color:#2185d0}body div#neuron-theme-default-blue span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#2185d0}body div#neuron-theme-default-blue .deemphasized:hover div.item a:hover{color:#2185d0 !important}body div#neuron-theme-default-blue div#footnotes{border-top-color:#2185d0}body div#neuron-theme-default-violet .zettel-content h1{background-color:rgba(100,53,201,0.1)}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a{color:#6435c9}body div#neuron-theme-default-violet span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#6435c9}body div#neuron-theme-default-violet .deemphasized:hover div.item a:hover{color:#6435c9 !important}body div#neuron-theme-default-violet div#footnotes{border-top-color:#6435c9}body div#neuron-theme-default-purple .zettel-content h1{background-color:rgba(163,51,200,0.1)}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a{color:#a333c8}body div#neuron-theme-default-purple span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#a333c8}body div#neuron-theme-default-purple .deemphasized:hover div.item a:hover{color:#a333c8 !important}body div#neuron-theme-default-purple div#footnotes{border-top-color:#a333c8}body div#neuron-theme-default-pink .zettel-content h1{background-color:rgba(224,57,151,0.1)}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a{color:#e03997}body div#neuron-theme-default-pink span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#e03997}body div#neuron-theme-default-pink .deemphasized:hover div.item a:hover{color:#e03997 !important}body div#neuron-theme-default-pink div#footnotes{border-top-color:#e03997}body div#neuron-theme-default-grey .zettel-content h1{background-color:rgba(118,118,118,0.1)}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a{color:#767676}body div#neuron-theme-default-grey span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#767676}body div#neuron-theme-default-grey .deemphasized:hover div.item a:hover{color:#767676 !important}body div#neuron-theme-default-grey div#footnotes{border-top-color:#767676}body div#neuron-theme-default-black .zettel-content h1{background-color:rgba(27,28,29,0.1)}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a{color:#1b1c1d}body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a:hover{color:#ffffff;background-color:#1b1c1d}body div#neuron-theme-default-black .deemphasized:hover div.item a:hover{color:#1b1c1d !important}body div#neuron-theme-default-black div#footnotes{border-top-color:#1b1c1d}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.84999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f8f8f8}body div.zettel-view .zettel-content pre{padding:0.5em 0.5em 0.5em 0.5em;overflow:auto;max-width:100%}body div.zettel-view .zettel-content div.pandoc-code{margin-left:auto;margin-right:auto}body div.zettel-view .zettel-content div.pandoc-code pre{background-color:#f8f8f8}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.backlinks-container{background-color:#eeeeee !important}body ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body ul.context-list > li{list-style-type:lower-roman}body span.zettel-link-container span.zettel-link a{font-weight:bold;text-decoration:none}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}body nav.top-menu{padding-top:1em;padding-bottom:1em;justify-content:center;text-align:center}body nav.top-menu > *{padding-left:0px;padding-right:0px}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}</style><link href="https://fonts.googleapis.com/css?family=Kanit|Ubuntu|Roboto+Mono&amp;display=swap" rel="stylesheet" /><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><meta content="Ben Kovach" name="author" /><meta content="This is the second in a series of posts about category theory and its
relationship with Haskell. We’ll be exploring monoids in this post!
" name="description" /><link href="https://kovach.me/Monoids_in_Theory_and_in_Haskell.html" rel="canonical" /><meta content="Monoids in Theory and in Haskell" property="og:title" /><meta content="Ben Kovach" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[]</script><style type="text/css">pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style></head><body><div class="ui fluid container" id="neuron-theme-default-blue"><nav class="top-menu"><div class="ui inverted compact neuron icon menu blue"><a class="left item" href="." title="Home"><i class="home icon"></i></a><a class="left item" href="search.html" title="Search Zettels"><i class="search icon"></i></a><a class="center item" href="https://github.com/5outh/zettelkasten/edit/master/Monoids in Theory and in Haskell.md" title="Edit this Zettel"><i class="edit icon"></i></a><a class="right item" href="z-index.html" title="All Zettels (z-index)"><i class="tree icon"></i></a></div></nav><div class="ui text container" id="zettel-container" style="position: relative"><div id="zettel-container-anchor" style="position: absolute; top: -24px; left: 0"></div><div class="zettel-view"><article class="ui raised attached segment zettel-content"><h1>Monoids in Theory and in Haskell</h1><div class="pandoc"><h2 id="overview">Overview</h2><p>This is the second in a series of posts about category theory and its relationship with Haskell. We’ll be exploring monoids in this post!</p><h2 id="the-monoid-intuitively">The monoid (intuitively)</h2><p>A monoid is a mathematical object, just like a category, <a href="http://kovach.me/posts/2016-06-01-categories.html">which we explored in the last post</a>. Intuitively, a monoid is a structure which encodes the ability to concatenate two things, and a zero-like element which, when used in concatenation, does not affect the other element. Let’s look at a typical mathematical formulation of a monoid:</p><p>A <strong>monoid</strong> is a set <span class="math inline">\(M\)</span> equipped with a binary operation <span class="math inline">\(\times : m \rightarrow m \rightarrow m\)</span> and a special element <span class="math inline">\(1 \in M\)</span> such that <span class="math inline">\(1\)</span> and <span class="math inline">\(\times\)</span> satisfy the following laws:</p><ul><li>Associativity: <span class="math inline">\((x \times y) \times z = x \times (y \times z)\)</span></li><li>Left and right unit laws: <span class="math inline">\(1 \times x = x = x \times 1\)</span></li></ul><p>I wouldn’t be surprised at this point if, even without a heavy mathematical background, one could come up with an example of a monoid. Let’s look at a couple.</p><p>The monoid <span class="math inline">\(\{\mathbb{R}, \times, 1\}\)</span> is an obvious example of a monoid; that is, our set <span class="math inline">\(M\)</span> is the <strong>real numbers</strong>, our binary operation is <strong>multiplication</strong>, and our <span class="math inline">\(1\)</span> element is the number <strong>1</strong>.</p><p>Another example of a monoid on numeric values is <span class="math inline">\(\{\mathbb{Z}, +, 0\}\)</span>; the <strong>integers</strong> under <strong>addition</strong> with <span class="math inline">\(1\)</span> being <strong>0</strong>.</p><p>In the programming world, monoids show up all over the place as well. A well-known monoid, using haskell syntax, is <code>{[a], (++), []}</code> – the monoid of <strong>lists</strong> under <strong>concatentation</strong> with <span class="math inline">\(1\)</span> being the <strong>empty list</strong>.</p><h2 id="the-monoid-in-haskell">The monoid (in haskell)</h2><p>As a haskell programmer, the aforementioned definition for a monoid looks awfully familiar. The typeclass for <code>Monoid</code> looks almost the exact same, sans axioms, and modulo names, as the traditional mathematical formulation:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">class</span><span class=""> </span><span class="dt">Monoid</span><span class=""> m </span><span class="kw">where</span>
<span class="ot">  mempty ::</span><span class=""> m </span><span class="co">-- Analogous to 1</span>
<span class="ot">  mappend ::</span><span class=""> m </span><span class="ot">-&gt;</span><span class=""> m </span><span class="ot">-&gt;</span><span class=""> m </span><span class="co">-- Analogous to our binary operation </span>
</code></pre></div><p>We can even encode the three examples of monoids mentioned above in a very straightforward way:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="co">-- Let&#39;s pretend Floats are the reals </span>
<span class="co">-- {R, *, 1}</span>
<span class="kw">newtype</span><span class=""> </span><span class="dt">Product</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">Product</span><span class="">{</span><span class="ot"> runProduct ::</span><span class=""> </span><span class="dt">Float</span><span class=""> }</span>

<span class="kw">instance</span><span class=""> </span><span class="dt">Monoid</span><span class=""> </span><span class="dt">Product</span><span class=""> </span><span class="kw">where</span>
<span class="">  </span><span class="fu">mempty</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">Product</span><span class=""> </span><span class="dv">1</span>
<span class="">  </span><span class="fu">mappend</span><span class=""> (</span><span class="dt">Product</span><span class=""> a) (</span><span class="dt">Product</span><span class=""> b) </span><span class="ot">=</span><span class=""> </span><span class="dt">Product</span><span class=""> (a </span><span class="op">*</span><span class=""> b)</span>

<span class="co">-- {Z, +, 0}</span>
<span class="kw">newtype</span><span class=""> </span><span class="dt">Sum</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">Sum</span><span class="">{</span><span class="ot"> runSum ::</span><span class=""> </span><span class="dt">Integer</span><span class=""> }</span>

<span class="kw">instance</span><span class=""> </span><span class="dt">Monoid</span><span class=""> </span><span class="dt">Sum</span><span class=""> </span><span class="kw">where</span>
<span class="">  </span><span class="fu">mempty</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">Sum</span><span class=""> </span><span class="dv">0</span>
<span class="">  </span><span class="fu">mappend</span><span class=""> (</span><span class="dt">Sum</span><span class=""> a) (</span><span class="dt">Sum</span><span class=""> b) </span><span class="ot">=</span><span class=""> </span><span class="dt">Sum</span><span class=""> (a </span><span class="op">+</span><span class=""> b)</span>

<span class="co">-- This one is defined in the Prelude</span>
<span class="co">-- {[a], ++, []}</span>
<span class="kw">instance</span><span class=""> </span><span class="dt">Monoid</span><span class=""> [a] </span><span class="kw">where</span>
<span class="">  </span><span class="fu">mempty</span><span class=""> </span><span class="ot">=</span><span class=""> []</span>
<span class="">  </span><span class="fu">mappend</span><span class=""> xs ys </span><span class="ot">=</span><span class=""> xs </span><span class="op">++</span><span class=""> ys</span>
</code></pre></div><p>We have to verify that our instances follow the laws, which translated to haskell look like this:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="co">-- Associativity</span>
<span class="">(a </span><span class="ot">`mappend`</span><span class=""> b) </span><span class="ot">`mappend`</span><span class=""> c </span><span class="op">==</span><span class=""> a </span><span class="ot">`mappend`</span><span class=""> (b </span><span class="ot">`mappend`</span><span class=""> c)</span>

<span class="co">-- Left/right unit laws</span>
<span class="fu">mempty</span><span class=""> </span><span class="ot">`mappend`</span><span class=""> a </span><span class="op">==</span><span class=""> a </span><span class="op">==</span><span class=""> a </span><span class="ot">`mappend`</span><span class=""> </span><span class="fu">mempty</span>
</code></pre></div><p>It is not so hard to reason through these laws for the instances listed above.</p><h2 id="the-monoid-in-category-theory">The monoid (in category theory)</h2><p>We’re not done quite yet, because category theorists have picked up on a quaint definition of a monoid:</p><blockquote><p>A <strong>monoid</strong> is a category with one object.</p></blockquote><blockquote><p>~ <a href="http://www.springer.com/us/book/9780387984032">Mac Lane, 1978</a></p></blockquote><p>Well, that’s convenient. But what is really going on here? Let’s look at a visual representation of the category theory interpretation of <span class="math inline">\(\{\mathbb{Z}, +, 0\}\)</span> that we saw before*:</p><img src="https://ben-kovach-blog-assets.s3.amazonaws.com/images/monoid.png" style="width:350px" class="center-block">
<small>* The image gets a little messy with the negatives, but those are valid
arrows as well.</small>
<p>Morphisms in our category are elements of <span class="math inline">\(\mathbb{Z}\)</span>. This can be confusing if we have some expectation about the way arrows should look. But, recall that to define a morphism, we only need to be able to assign a source and target to them, which are totally abstract concepts. Our set of morphisms is then exactly <span class="math inline">\(\mathbb{Z}\)</span>, where we just pick the same source and target for every single element.</p><p><span class="math inline">\(id\)</span> is the arrow labeled <span class="math inline">\(0\)</span>:</p><img src="https://ben-kovach-blog-assets.s3.amazonaws.com/images/morphisms_0.png" style="width:350px" class="center-block">
<p>Here are two more arrows:</p><img src="https://ben-kovach-blog-assets.s3.amazonaws.com/images/morphisms_1.png" style="width:350px" class="center-block">
<p>Composing these arrows gives us something that looks like this, intuitively:</p><img src="https://ben-kovach-blog-assets.s3.amazonaws.com/images/morphisms_2.png" style="width:350px" class="center-block">
<p>Composition is addition, so this is equivalent to:</p><img src="https://ben-kovach-blog-assets.s3.amazonaws.com/images/morphisms_3.png" style="width:350px" class="center-block">
<p>An important thing to note here is that <strong>the object doesn’t really matter</strong>. The above diagrams should make sense regardless of what the source and target of the arrows are, as long as they’re the same thing. The source and target <strong>must</strong> be the same so we can compose freely. If they weren’t, we wouldn’t be guaranteed to “have access” to the start of any arrow in our monoid at the end of any other arrow, which would disallow composition. This means we necessarily only have a single object in our category.</p><p>So long as we have a monoid by the classical definition, we have a monoid by the category theoretical definition. The conceptual mapping of formulations (from classical to category theoretical) is:</p><ul><li><span class="math inline">\(\times \rightarrow \circ\)</span></li><li><span class="math inline">\(1 \rightarrow id\)</span></li></ul><p>The tricky thing here is that in category-theory-land, the morphisms might not really look like functions, or even arrows, as we might expect. An integer as a category morphism follows the laws if we plug in the right <span class="math inline">\(id\)</span> and <span class="math inline">\(\circ\)</span>, and that’s all that matters.</p><h2 id="the-connection">The connection</h2><p>Let’s formulate the aforementioned <code>Sum</code> as a legitimate haskell <code>Category</code> (<code>C</code> for <code>Category</code>):</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="kw">data</span><span class=""> </span><span class="dt">SumC</span><span class=""> a b </span><span class="kw">where</span>
<span class="">  </span><span class="dt">SumC</span><span class="ot"> ::</span><span class=""> </span><span class="dt">Integer</span><span class=""> </span><span class="ot">-&gt;</span><span class=""> </span><span class="dt">SumC</span><span class=""> a a</span>

<span class="kw">deriving</span><span class=""> </span><span class="kw">instance</span><span class=""> </span><span class="dt">Show</span><span class=""> (</span><span class="dt">SumC</span><span class=""> a b)</span>

<span class="kw">instance</span><span class=""> </span><span class="dt">Category</span><span class=""> </span><span class="dt">SumC</span><span class=""> </span><span class="kw">where</span>
<span class="">  </span><span class="fu">id</span><span class=""> </span><span class="ot">=</span><span class=""> </span><span class="dt">SumC</span><span class=""> </span><span class="dv">0</span>
<span class="">  </span><span class="dt">SumC</span><span class=""> x </span><span class="op">.</span><span class=""> </span><span class="dt">SumC</span><span class=""> y </span><span class="ot">=</span><span class=""> </span><span class="dt">SumC</span><span class=""> (x </span><span class="op">+</span><span class=""> y)</span>
</code></pre></div><p>We can use GADTs to encode the monoid (read: category with a single object) of integers under addition. We are saying two things here:</p><ul><li>A <code>SumC</code> is constructed by an <code>Integer</code> (effectively, this means that a <code>SumC</code> <em>is</em> an <code>Integer</code>; this is just a wrapper).</li><li>Although we’re providing two type variables to <code>SumC</code>, we can only construct things of type <code>SumC a a</code>.</li></ul><p>In effect, if we view <code>SumC</code> as <code>cat</code> (the type of morphisms in a category), we can encode the monoid <span class="math inline">\(\{\mathbb{Z}, +, 0\}\)</span> exactly as a <code>Category</code>. If you look closely, you’ll notice that we only have a single object in our category, and we don’t care what it is. This is exactly <code>a</code>. A <code>SumC</code> can only be constructed in one way, namely, by asserting that its source and target is <code>a</code>. The identity arrow is <code>0</code>, which we’d expect, and composing two arrows is adding their <code>Integer</code> values.</p><p>The category laws all hold, which you may check. This instance acts exactly like the builtin <code>Monoid</code> instance for the <code>Sum</code> we saw previously, modulo operator/function names*:</p><div class="pandoc-code highlighted"><pre><code class="haskell"><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> </span><span class="dt">SumC</span><span class=""> </span><span class="dv">8</span><span class=""> </span><span class="op">.</span><span class=""> </span><span class="fu">id</span>
<span class="dt">SumC</span><span class=""> </span><span class="dv">8</span>
<span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> </span><span class="fu">id</span><span class=""> </span><span class="op">.</span><span class=""> </span><span class="dt">SumC</span><span class=""> </span><span class="dv">8</span>
<span class="dt">SumC</span><span class=""> </span><span class="dv">8</span>
<span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span><span class=""> </span><span class="dt">SumC</span><span class=""> </span><span class="dv">17</span><span class=""> </span><span class="op">.</span><span class=""> </span><span class="dt">SumC</span><span class=""> </span><span class="dv">90</span>
<span class="dt">SumC</span><span class=""> </span><span class="dv">107</span>
</code></pre></div><small>
* s/id/mempty, s/./+, s/SumC/Sum and you've got the original form.
</small>
<p>Just like with a <code>Category</code>, this isn’t the only <code>Monoid</code> you can encode – you should be able to use this type of construction for any haskell <code>Monoid</code>.</p><p>Note that I wouldn’t actually recommend doing this in practice; it’s mainly a mental exercise. That said, I think it’s pretty cool that we can get very close to a category-theoretic formulation of what a monoid is in Haskell!</p></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2016-06-08">2016-06-08</time></div></div></article><nav class="ui bottom attached segment deemphasized backlinks-container"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" data-inverted="" data-position="right center" data-tooltip="Tags: home"><a href=".">Ben Kovach</a></span></span><ul class="context-list" style="zoom: 85%;"><li class="item"><div class="pandoc">Linking by tag: <code>Essays</code></div></li></ul></li></ul><a class="ui right ribbon label zettel-tag " href="search.html?tag=Haskell" title="See all zettels tagged &#39;Haskell&#39;">Haskell</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Category Theory" title="See all zettels tagged &#39;Category Theory&#39;">Category Theory</a><p></p><a class="ui right ribbon label zettel-tag " href="search.html?tag=Essays" title="See all zettels tagged &#39;Essays&#39;">Essays</a><p></p></nav></div></div><div class="ui one column grid footer-version"><div class="center aligned column"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron" /></a></div></div></div></div></body></html>